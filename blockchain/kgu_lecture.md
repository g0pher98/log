1. bitcoin
    - what is bitcoin?
        - 전자화폐 시스템(분산화된, 탈중앙화된 시스템)의 기반이 되는 개념과 기술들이 모여서 만든 플랫폼
        - 참여자들은 기존 화폐처럼 활용할 수 있음
            - 물건 구매/판매
            - 송금, 교환, 환전
        - 가상화폐/암호화폐
            - 암호화폐라는 말을 선호함. 가상화폐라는 말은 기존에 있던 포인트, 마일리지와 같은 개념이기 때문에 비트코인은 정확히는 암호화폐로써 차별화된 기술이라는 점이 중요.
            - 물리적/전자적 coin 개념은 사실 없음. 그래서 정확히 몇 비트코인이 있다! 이런 식의 개념이 없음.
                - 거래소에서 뜨는건?
                    - 정확히는 transaction(거래, tx)이 있고, 그 안에 함축적으로 표현되는 것임.
            - bitcoin의 소유권은 cryptographic key가 증명함.
            - bitcoin을 소비하기 위해서는 key를 이용한 전자서명을 생성해야 함.
            - key는 보통 wallet(지갑)에 저장해서 사용.
        - distributed, peer-to-peer(p2p) 시스템으로 구성되어있음.
            - 완전히 분산되어 별도의 중앙서버가 존재하지 않음.
                - 중앙서버의 상태에 따라 전체 생태계가 크게 영향받는다는 점을 해소
            - 신규 bitcoin은 mining이라 불리는 합의과정 중에 생성됨
                - 누구나 mining 과정에 참가할 수 있음
            - 모든 transaction은 blockchain을 통해 저장됨
        - 신규 bitcoin 발행
            - 중앙 서버가 없는데 누가 보상을 주나?
                - mining에 성공한 채굴자가 보상으로 새로 발행된 bitcoin을 획득.
            - 대략적으로 10분마다 하나씩 발행할 수 있도록 난이도 조절이 됨.
                - 노드가 적으면 적을 수록 쉬운 문제,
                - 많으면 많을수록 어려운 문제
            - 보상 규모는 대략 4년 주기로 보상이 반으로 줄어드는 반감기를 거침.
                - 점점 반으로 줄어드니 나중에는 보상이 거의 없어짐.
                    - 새로운 코인이 거의 발행되지 않기 때문에 안정적으로 운용됨.
                    - 2020년 보상 규모는, 채굴당 6.25 bitcoin
    - bitcoin 구성요소
        - bitcoin protocol
            - 여러 노드들이 분산된 p2p 네트워크를 구성해서 통신이 가능하도록 하는 프로토콜이 필요
        - blockchain
            - 공적인 거래장부(원장)
            - 누구나 열람할 수 있음
        - consensus rules
            - 트랜젝션이 올바른지, 올바르게 소유하고 있는지 검증하는 룰
        - proof-of-work (PoW)
            - 사용자들이 거래내역이 맞는지 일종의 합의를 끌어내기 위해 사용하는 알고리즘
    - 비트코인 이전의 가상화폐
        - 가상화폐가 되려면
            - 진짜인가? 위조인가? 발행하지 않았는데 가짜로 만든게 아닌가? 이를 검증할 수 있어야 함.
            - 물리적 화폐로는 불가능하지만, 논리적인 화폐는 동시간대에 결제를 하는 double spending 문제를 해결할 수 있어야 함.
            - 소유자가 A가 맞는지 검증할 수 있어야 함.
        - 기존 가상화폐
            - 중앙집중형 방식이었음
            - 중앙서버가 공격자의 주요 타겟이 되고 SPoF(single point of failure) 문제 발생
    - 캐릭터
        ![image](https://user-images.githubusercontent.com/44149738/132997872-acfd2692-feac-4d5c-badb-f3b1073a043a.png)
    - 지갑
        - 비트코인을 사용할 수 있도록 정보들을 저장하는 공간
        - 플랫폼에 따른 분류
            - desktop wallet
            - mobile wallet
            - web wallet
            - hardware wallet
            - paper wallet
        - 역할과 동작방식에 따른 분류
            - full-node client
                - 모든 transaction을 저장하고 검증하는 역할.
                - 적극적으로 비트코인 운영에 관여함.
                - full-node가 많아지면 비트코인이 더욱 견고해지지만, 상당한 리소스때문에 일반 사용자는 full-node가 되기 어려움.
            - lightweight client(SPV client)
                - transaction 정보를 얻기 위해서는 full-node에 연결해야함.
                - 지갑 사용자에 관련된 transaction 처리만 담당. 가벼움.
            - third-party API client
                - 직접적으로 연결하지 않고, third-party 시스템을 이용해 bitcoin에 연결
        - bitcoin core
            - bitcoin에 참여하는 노드가 되기 위한 방법.
            - 가장 대표적인 reference implementation
        - quick start
            - 지갑이 개인키/공개키를 생성하고, 공개키를 바탕으로 address 생성.
            - address는 다른 사람들과 공유
            - address가 생성되었다고 바로 비트코인에 등록되는 개념은 아니고 실제로 거래가 이루어져서 트랜젝션이 발생하면 그때 bitcoin system에 기록됨
        - bitcoin 획득 방법
            - 기존 사용자로부터 구매
            - 물건/서비스 판매를 통한 획득
            - ATM 기기를 이용한 구매
            - 거래소를 통한 구매
        - 송금
            1. 특정 address에 대해 btc 전달 요청
            2. wallet은 이 요청을 기반으로 transaction 생성 후 wallet 내 개인키를 통해 signing
            3. bitcoin network에 transaction 전파( < 1sec)
            4. 수신자는 몇초 후에 확인 가능
            - 그러나 이는 unconfirmed 상태임. (블록체인 네트워크에 기록되진 않았음.)
            - 10분마다 mining이 수행이 될 때, 트렌젝션이 블록에 추가가 되면 confirmed 상태가 됨.
            - 이제서야 수신자는 해당 비트코인에 대해 정상적인 소유자가 됨.

2. transactions
    - 구조
        - double-entry bookkeeping 과 비슷한 방식. 
        - input을 output의 형태로 가치를 변화시키는 것.
        - transaction 안에는 inputs(수입) 와 outputs(지출)에 대한 내용과 그 합계가 있다.
        - (outputs 합) - (inputs 합) = 수수료
        - input의 신뢰성을 판단하는 방법
            - 이전 트랜젝션에서 받은 output을 기반으로 input 형성
        - 잔돈은 잔돈이라고 명시하지는 않지만 다시 보내는 output을 형성함으로써 구현
            - 일반적으로 익명성을 위해 같은곳으로 잔돈을 받지 않음.
    - 올바른 input 구성하기
        - 주소를 이용한 검색으로 해당 주소에 output으로 들어온 트랜젝션을 탐색
        - output에 있지만 이후 input으로 사용된 트랜젝션은 이미 소진된 거래이기 때문에 제외.
        - full-node client
            - 모든 노드를 탐색
        - lightweight client
            - 모든 트랜젝션을 저장할수는 없으니 본인이 관심이 있는 항목에 대해서만 모아서 저장.
            - 만약 정보가 누락되거나 부족할 경우, 주변의 full node client에게 정보 요청
    - output 구성하기
        - 실제로는 스트립트를 만들어서 output 구성
        - 누군가 output을 사용하려고 할 때, 스크립트에 대한 솔루션을 제시해야지만 사용할 수 있음.
    
3. mining
    - 최근 트렌젝션을 잘 모아서 확인하고, 모아서 하나의 새로운 블럭을 만들어서 비트코인에 추가하는 것을 mining이라고 함.
    - 블럭 생성은 누구나 할 수 있음. 이것이 블록체인에 받아들여지기 위해서 mining 이라는 과정이 필요한 것임.
    - 비트코인에서는 mining이라는 과정을 통해 pow라는 방식을 사용하게 됨.
    - 채굴자는 두 가지 보상을 받음
        1. block을 받음
        2. tx 의 수수료를 받음
        - 리워드는 tx 안에 먼저 넣고 채굴을 진행
    - PoW(Proof of Work)
        - prove는 무지무지 많은 연산이 필요
        - verify는 초-간단하게 확인할 수 있도록 함.
    - block이 쌓이면 쌓일수록 아래에 있는 block은 그만큼 여러번 검증이 되었다고 볼 수 있기 때문에 신뢰성이 높아진다
    - 보통 6번 이상 쌓이게 되면 더이상 수정이 어려워진다.
        
4. bitcoin core
    - 대표적인 비트코인 구현체
    - 레포 : https://github.com/bitcoin/bitcoin.git
    - 보통 비트코인 관련 개발자라면 full node로 진행함.
        - 필요한 데이터를 바로 뽑아와야 하기 때문
    - 필요사항
        - disk 공간 > 300GB 
            - 시간이 지날수록 점점 커짐
        - ram > 2G
        - 빠른 인터넷 대역폭
    - bitcoind (bitcoin core daemon)
        - `bitcoind -printtoconsole -txindex=1`
    - bitcoin-cli
        - 비트코인 코어 인터프리터 
        - `bitcoin-cli getblockchaininfo`

    - API 구조
        - bitcoind는 데몬으로, 안정적으로 서버에서 웹을 구동시킨다. 웹 상에서 `JSON-RPC 2.0` 형태로 서비스를 제공한다.
        - client는 어떤 형태로든 bitcoind 규격(rpc)에 맞춰서 요청을 하면 원하는 데이터를 응답받을 수 있다.
    - API 사용
        - `curl --user username:credential --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method":"getblockchaininfo", "params": []}' -H 'content-type: text/plain;' http://127.0.0.1:8332/`
        - `python-bitcoinlib` 라이브러리를 사용하면 python 코드를 간단하게 짜서 질의할 수 있음.
    - 동기화
        - full node에 필요한 block들을 모두 가져오는 과정
        - mainnet : 실제 네트워크
        - testnet : 테스팅용. 이것마저 큼,,,
    - API
        - `getrawtransaction()`
            - block hash, txid를 파라미터로 받음
            - raw한 transaction 그 자체
        - `decoderawtransaction()`
            - raw한 transaction을 파라미터로 받음
            - raw한 transaction을 디코딩
        - `getblockhash()`
            - block height를 파라미터로 받음
            - block hash를 반환
        - `getblock()`
            - block hash를 파라미터로 받음
            - block 정보를 받음
            - block 내 txid들을 확인할 수 있음
    - python
        - `python-bitcoinlib` 라이브러리가 있음
        - `from bitcoin.rpc import RawProxy` 형태로 import
        - `p = RawProxy(); p.getblockchaininfo()` 형태로 사용
        - 이 외에도 다양한 언어, 다양한 라이브러리가 존재함.

5. bitcoin address
    - bitcoin의 owner인지 확인할 수 있는 key 존재
    - bitcoin에서는 공개키 시스템을 사용
        - one way function, trap door 특성 활용
    - key는 비트코인에 기록되지 않고, 사용자가 저장해야 함.
    - 대신 priv key를 기반으로 pub key를 만들고 이를 기반으로 address가 생성됨.
    - key를 이용해서 전자서명을 하는 방식. -> 소유 증명.
    - 암호화를 하는 것 보다는 전자서명을 하는 것에 집중.
    - 비트코인은 ECDSA 라는 타원곡선 기반 암호화를 사용
        - 타원곡선 상에서 덧셈을 활용
            - ![image](https://user-images.githubusercontent.com/44149738/134524440-8e1e584e-a73f-4a28-953d-def4370ca5ff.png)
            1. 두 점을 잇는 직선을 그림
            2. 직선과 만나는 타원곡선의 한 점을 찾음
                - 교점이 없는 경우 point at infinity라고 하며 0의 값을 가짐.
            3. 교점에 x축 대칭인 점이 두 점의 합인 지점.
            - 2P = P + P
            - kP = P + P + ... + P (k times)
            - priv key는 256bit의 정수.
    - 비트코인에서는 `secp256k1` 이라는 타원곡선 암호시스템을 사용
        - 다른 시스템에 비해 연산이 빠르고 안전함.
        - ![image](https://user-images.githubusercontent.com/44149738/134524520-58cf6eee-bedd-4db8-90b1-1cd0018e6616.png)
        - mod 연산을 거치면서 타원곡선이 선이 아닌 점의 형태로 나타남.
    - 생성된 public key는 두 번의 hashing을 이용해서 address를 생성한다.
        - ![image](https://user-images.githubusercontent.com/44149738/134527382-3ea945fe-0737-4490-9623-be546abd68cf.png)
        - sha256 해싱
        - RIPEMD160 해싱
        - base58check encode
            - b58 : 헷갈리는 단어를 뺀 58개 character로 인코딩
            - b58check : b58에 추가로 version과 checksum
                1. 머리에 version(1byte)
                    - address 데이터는 0x00이 붙음
                    - 이 때문에 항상 address 결과의 첫글자가 1이 되도록 함.
                    - 이 외에도 다양한 prefix 값이 존재
                2. 꼬리에 checksum(4bytes)
                    - 이중으로 sha256 hashing 후 앞 4 bytes
                3. 최종 b58 encoding

6. key formats
    - priv key formats
        - WIF(Wallet Import Format)
            - prefix 값으로 5가 들어감
        - WIF-compressed
            - HEX + suffix 01
            - 위 데이터를 WIF로 나타냄
            - K로 시작하는 것이 특징
    - pub key formats
        - K = (x, y)
        - prefix 04 + x + y => 너무 길어짐.
        - compressed -> x값만 저장
            - 타원곡선 함수는 정해져있기 때문에 x값으로 y를 알 수 있음
            - 그러나 x에 대한 y가 두 개일 수 있음.
            - prefix 02 : 짝수(y가 음수)
            - prefix 03 : 홀수(y가 양수)
            - compressed를 사용하기 위해서는 priv key에 명시해주어야 함.(WIF-compressed)
    - lib
        - python ecdsa
        - python pybitcointools (by Vitalik Buterin:이더리움 창시자)

7. 기타 다양한 address
    - P2PKH(Pay to public key hash)
        - 가장 기본적인 형태
        - 1로 시작
    - P2SH(Pay to script)
        - 3으로 시작
        - 특정 한 명의 key를 이용해서 address를 생성하지 않음
        - 임의의 script를 만들 수 있음. -> 이에 대한 hash갑이 address
            - A = RIPEMD160(SHA256(script))
        - script를 unlock할 수 있는 사람이 곧 소유자
        - b58check로 version 5로 encoding하기 때문에 결과가 3으로 시작.
        - multi-signature 기능 구현에 많이 사용됨
            - address로 들어온 bitcoin을 사용하기 위해서는 2개 이상의 여러개의 전자서명이 제공이 되어야 한다.
            - M of N multisig
                - N개 키 중 M개의 키를 이용해 서명을 만들어야 사용할 수 있다.
                - 이 M을 Threshold 라고 볼 수 있음
            - 왜 쓰는가?
                - 부부와 같이 공동 계좌 개념으로 운영하는 경우 사용할 수 있음. (1 of 2)
                - 회사 직원이 공동 계좌를 사용할 때 여러명의 검토 및 승인을 거치게 할 수 있음.
    - vanity address
        - 사람이 보다 알아보기 쉬운 address
        - 앞글자는 1인 일반적인 주소지만 그 뒤에 특정 단어를 넣을 수 있음
        - `1LoveBPzzD...`
        - brute-force 방식으로 획득.
        - 안정성에는 문제 없음. 기존 address와 동등한 수준의 안정성.
        - 고정하려는 단어가 길수록 오래걸림.
            - 4자리 1분
            - 5자리 1시간
            - 6자리 2일
        - GPU를 활용해서 연산하는 방식도 사용
        - pool을 관리하는 방식도 존재
    - paper wallets
        - 종이에 프린트해서 저장하는 wallet
        - priv key를 qr 형태로 출력
        - 주로 key 백업용도로 사용

8. wallet
    - wallet은 사용자 친화적, 보안, 유연성 등을 고려해야 함.
    - wallet이 가상화폐를 담고있는 공간이라는 오해를 하는 경우가 있다.
        - 화폐가 존재하는게 아니라 key만 존재한다.
        - 이 key를 이용해서 장부에 기록되어있는 내용을 사용하는 것.
    - 종류
        - non-deterministic wallet
            - ![image](https://user-images.githubusercontent.com/44149738/136514710-42535242-fd0f-4a65-bd75-3f527d441681.png)
            - 결정적이지 않다.
            - 각각의 키가 연관성이 있는게 아니라 무작위로 생성
            - 비트코인 초기단계에서 주로 사용했었음.
        - deterministic wallet
            - 각각의 키가 독립적이지 않고 연관성이 있음.
            - 니모닉 코드라는 seed 사용
            - type-1 wallet
                - ![image](https://user-images.githubusercontent.com/44149738/136514757-5c3ded42-5e8d-4aca-ba3b-fcabb03aac8a.png)
                - 기본적인 형태의 wallet
                - 이전 address와 관련된 seed를 기반으로 다음 wallet 생성.
                - 초기 seed만 알고있으면 모든 wallet 복원 가능하기 때문에 백업 리소스 크게 감소.
            - HD wallet(type-2)
                - ![image](https://user-images.githubusercontent.com/44149738/136514826-7f0bf093-821f-4c54-8f20-d35cc5228076.png)
                - tree 구조를 띔.
                - seed -> master key를 생성
                - master key를 최상위 부모로 하여 트리구조로 child key 확장.
                - 만들어진 키의 구조가 조직화된다는 장점이 있음.
                - priv key를 공개하지 않고도 거래가 가능하다는 장점이 있음.
    - Mnemonic code
        - seed값을 저장하기에 사용자 입장에서 어려울 수 있음
        - 이를 보다 사용자 친화적이게 바꾼것이 니모닉 코드
        - 즉, 시드값을 읽을 수 있는 형태로 변환
        - 12 ~ 24개의 단어로 구성
        - ![image](https://user-images.githubusercontent.com/44149738/136516631-d7261329-1f44-4630-a416-0519b3abbda3.png)
        - 니모닉 코드 = findInDict(랜덤값(128bit) + sha256(랜덤값) 앞 4bit)
        - 니모닉 코드 to Seed
            - ![image](https://user-images.githubusercontent.com/44149738/136517633-0a4bcb31-37a7-48bf-97ff-e99de37c900a.png)
            - seed = PBKDF2(니모닉코드 + salt(mnemonic + password))
            - 사용자의 password를 연산에 추가하여 니모닉 코드가 유출되어도 안전함.
    - creating hd wallet from seed
        - master priv key   =  left(hmac_sha512(seed), 256)
        - master chain code = right(hmac_sha512(seed), 256) = seed for child keys
        - child key 생성 방법 (CKD : Child Key Derivation)
            - ![image](https://user-images.githubusercontent.com/44149738/136524107-f1279316-dffa-4b67-8bcd-1ba06186a385.png)
            - parent의 priv key와 hmac 연산결과를 더한 것이 child priv key가 됨.
            - ![image](https://user-images.githubusercontent.com/44149738/136524233-8114a04e-2a4e-42b0-83fd-43c06134be8b.png)
            - parent priv key가 없어도 child를 생성 가능.
                - 상위 노드의 key를 서버에 저장하지 않아도 된다는 장점

9. key
    - Entended key
        - (priv/pub key + chain code) 이렇게 두 개의 값을 묶어놓은 것.
        - 이 두개만 알면 child key들을 생성할 수 있음.
        - xprv = priv key + chain code
        - xpub = pub key + chain code 
    - Hardened key
        - 기존 방식은 잠재적인 위험이 있음.
            - xpub와 child의 priv key가 노출이 되면 parent의 priv key를 얻을 수 있음
            - ![image](https://user-images.githubusercontent.com/44149738/136526733-7a500138-a4be-46c9-b042-13cb3a34a3a8.png)
        - 위 문제를 개선하고자 hardened derivation 이 나옴.
        - priv key로만 계산하도록 구성
            - child key로 parent key를 얻을 수 없음.
            - parent와 child 사이에 벽을 하나 만드는 느낌
        - 이 방법을 쓰게되면 xpub의 장점을 사용할 수 없게됨. pub key로만 쉽게 만들 수 없음. 무조건 priv key 필요.
    - 실제로는 위 방법을 혼합해서 사용
        - ![image](https://user-images.githubusercontent.com/44149738/136527245-06f61817-e6d1-480a-a03f-8aedf69043a6.png)
        - 최초의 child는 hardened 방식을 사용해서 parent key가 유출되지 않도록 구성하고, 그 하위부터는 일반적인 방법으로 생성. 결국에 뚫려도 최상위 master key는 안전함.
    - key의 identifier
        - index number는 32bit의 크기를 가짐. 즉, 10의 32승개의 key 생성 가능
        - index의 첫 1bit를 통해 normal 방식인지, hardened 방식인지 판단
            - 0x00000000 ~ 0x7fffffff : normal
            - 0x80000000 ~ 0xffffffff : hardened
        - key에 id를 부여
            - key가 tree의 어느 위치에 존재하는지 파악할 수 있도록 설정
            - m : priv key
            - M : pub key
            - 0' : hardend 방식으로 생성된 child 중 0번째.
            - M/23/17/0/0 : master key의 child 중 23번째 child 중 17번째 child 중 0번째 child 중 0번째 pub key
        - depth가 깊어지면 파악이 어려움.
            - BIP-44라는 규칙이 있음
            - `m / purpose' / coin_type' / account' / change / address_index`
                - purpose' : 44' (상수)
                - coin_type'
                    - bitcoin mainnet: `m/44'/0'`
                    - bitcoin testnet: `m/44'/1'`
                    - litecoin: `m/44'/2'`
                - account'
                    - 하나의 wallet이지만 여러개의 account를 만들 수 있음
                    - 회사 wallet을 여러 부서에서 사용하는 느낌
                    - `m/44'/0'/0'`, `m/44'/0'/0'`
                - change
                    - 0 : external chain : 외부 거래용
                    - 1 : internal chain : 내부 거래용 (잔돈처리 같은 활동에 사용)
                - address_index

10. transaction
    - 비트코인에서 가장 중요한 부분. 핵심.
    - transaction output
        - UTXO(Unspent Transaction Output)
            - ![image](https://user-images.githubusercontent.com/44149738/136531611-f386cd88-27ed-4624-bf2c-f35db3cdee6b.png)
            - tx output 중에서 아직 사용되지 않은 조각들을 관리
            - tx에 input으로 작용한 output은 사용한 output이기 때문에 사용된 output으로 취급
            - 모든 full 노드가 동일한 UTXO set을 얻을 수 있음.
            - tx가 발생할 때 마다 UTXO set은 계속 바뀜
            - 사용자 관점
                - address 에 맞는 tx가 생성되면 내 지갑에 돈이 들어왔음을 체크
                - UTXO set 내 합을 구해서 현재 내가 소유하고 있는 전체 돈을 알 수 있음.
        - UTXO를 사용하지 않는 TX가 있음
            - 이를 coinbase tx라고 함
            - 채굴을 통해 얻는 경우임.
        - 구조
            - ![image](https://user-images.githubusercontent.com/44149738/136534192-c7d745a8-a79a-416b-99bb-ae0ca842e4a3.png)
            - value로 사토시 단위의 금액 기술
            - scriptPubKey 를 통해서 이 output을 사용할 수 있는 자격 명시
                - locking script가 정확한 표현
    - transaction input
        - 기존 UTXO를 소비를 해서 새로운 UTXO를 만듦.
        - 구조
            - ![image](https://user-images.githubusercontent.com/44149738/136535381-fd0ee8ae-e6d5-43c3-b3ae-3cb79c81f94c.png)
            - txid로 어떤 utxo를 소비할 것인지 명시
            - vout으로 txid에 해당하는 tx의 output 중 몇 번째 output을 사용할 것인지 명시
            - scriptSig로 unlocking script를 적어서 사용 권한 명시
    - transaction fee
        - 수수료. 채굴자가 획득함.
        - 수수료 역할
            - 채굴의 보상이 되기 때문에 활발한 채굴을 유도. 이는 곧 안정적인 네트워크 운영으로 이어짐
            - 공격자는 dummy tx를 마구 날려서 다른 tx를 처리 못하는 dos 공격을 할 수도 있기 때문에 이를 방지하기도 함.
        - 수수료 책정
            - 일반적인 금융 거래에서는 금액을 기준으로 수수료가 책정됨.
            - 비트코인에서는 금액은 관심없음. tx의 크기가 중요.
                - tx 크기가 크면 소비해야하는 네트워크 자원과 스토리지가 많이 사용됨
            - tx 크기에 따라 책정하지만 그 비율은 시장경제원리에 따름. 많이 내면 빨리 tx가 반영되고, 적게내면 그만큼 늦게 반영됨.
            - 적정 수수료는 다음 사이트에서 계산해줌
                - https://bitcoinfees.earn.com
        - 수수료 지불 방법
            - output을 수수료만큼 제외한 금액으로 기록하면 됨.
            - 여기서 잔돈받는 address를 기입 안한다든지 실수가 발생하면 그만큼 수수료로 지불되는 거라서 그런 상황이 발생하면 채굴자는 냉큼 받아먹음.

11. transaction script
    - 스택기반 language임
        - 매우 심플한 구조
        - UTXO에 `locking script`라는 코드 생성
        - UTXO를 사용하기 위해서 `locking script`를 해결해야함.
        - tx의 input에 `unlocking script`를 작성해서 권한 증명
    - turing incompleteness 하다
        - loop나 분기하는 등 복잡한 코드가 없다.
    - stateless 하다
        - 외부 요인이 없음
        - 어떠한 노드에서 실행되어도 같은 결과를 가짐
    - locking script   
        - scriptPubKey 라는 이름으로 불림
        - 주로 공개키가 들어가기 때문
    - unlocking script
        - scriptSig 라는 이름으로 불림
        - 주로 시그니처(전자서명)이 들어가기 때문
    - validation
        - ![image](https://user-images.githubusercontent.com/44149738/136786125-31b0d83a-fc87-4205-8248-62e194bfbba4.png)
        - btc를 사용하기 위해 validation이라는 검증 과정 필요
        - unlocking script + locking script 이렇게 두 데이터를 잇는다
        - 각 노드는 이를 실행한다
    - script execution
        - 스택 기반이므로 push, pop 을 사용. 간단한 asm과 비슷한 형태
        - unlocking script + locking script를 왼쪽부터 읽는다.
        - 읽은 값이 숫자면 스택에 push
        - 명령이면 실행.
            - OP_ADD : pop 2개 -> push 결과
            - OP_EQUAL : pop 2개 -> 같으면 push TRUE
        - 실행이 모두 끝난 후에 스택에 TRUE 딱 한개의 값만 남았을 때, valid 하다고 본다.
            - 즉, 해당 UTXO를 소비할 수 있다.
    - 퀴즈
        ```
        Q. OP_3DUP OP_ADD 5 OP_EQUALVERIFY OP_ADD 4 OP_EQUALVERIFY OP_ADD 3 OP_EQUAL
        ```
        - OP_3DUP : 상위 3개 데이터 push
        - OP_ADD : 상위 2개 데이터 pop 후 합산결과 push
        - OP_EQUALVERIFY : 상위 2개 데이터 pop 후 다르면 오류
        - OP_EQUAL : 상위 2개 데이터 pop 후 같으면 1, 다르면 0 push
        - 풀이
            - 최종 실행 결과는 1이어야 함을 알고 있으므로 뒤에서부터 접근.
            - `3 OP_EQUAL` 이후에는 1만 남아야 하므로 스택에는 3이 있었어야 함.
            - `OP_ADD`의 연산 결과는 3임. (0,3) (3,0) (1,2) (2,1) 넷중 하나. (a1, a2) 라고 하겠음.
            - `4 OP_EQUALVERIFY` 결과가 정상이어야 하므로 추가로 4가 존재했어야 함. (4, a1, a2)
            - `OP_ADD`의 연산 결과는 4임. (0,4) (4,0) (3,1) (1,3) (2,2) 다섯 중 하나. (a3, a4) 라고 하겠음.
            - `5 OP_EQUALVERIFY` 결과가 정상이어야 하므로 추가로 5가 존재했어야 함. (5, a3, a4, a1, a2)
            - `OP_ADD`의 연산 결과는 5임. (0,5) (5,0) (4,1) (1,4) (3,2) (2,3) 여섯 중 하나. (a5, a6) 라고 하겠음.
            - `OP_3DUP`의 결과는 스택의 [0:3] 데이터와 [3:6] 데이터가 같음.
                - `OP_3DUP` 연산 이후 스택은  (a5, a6, a3, a4, a1, a2)임.
                - `a5 == a4 && a6 == a1 && a3 == a2` 를 만족하는 값을 찾으면 됨.
                - 위 조건 중 각각의 조건을 만족하지 않는 경우를 제거하면 다음과 같음.
                    - (a1, a2) = {(0,3) (3,0) (1,2) (2,1)}
                    - (a3, a4) = {(0,4) (3,1) (1,3) (2,2)}
                    - (a5, a6) = {(4,1) (3,2) (2,3)}
                - 가능한 조합은 다음과 같음
                    - `{3 2 1 3 2 1}`

12. P2PKH (pay to public key hash)
    - btc tx에서 가장 많이 사용됨.
    - locking script
        - 돈을 받을 사람의 public key의 hash 값을 script에 넣음
        - `DUP HASH160 <PubKeyHash> EQUALVERIFY CHECKSIG` script 구성
    - unlocking script
        - `<sign> <pubkey>`로 unlocking script를 구성
    - 동작방식
        - ![image](https://user-images.githubusercontent.com/44149738/137493000-979bf18f-7b1e-4b0d-9c94-604f12db48d0.png)
        - ![image](https://user-images.githubusercontent.com/44149738/137493190-65460f8b-cbcf-4a64-9aba-356f9d4618ff.png)
    - 목적 : 소유권 증명을 위해 결국 전자서명을 확인하는 것.
    - 비트코인에서 전자서명
        - UTXO의 올바른 소유주임을 증명하는데 사용.
        - TX를 만들어서 전파했다고 하면, 나중에 해당 거래를 부정할 수 없음(부인방지).
        - 중간에 누군가가 수신자를 변조했다고 했을 때, 이를 방지할 수 있음.
        - 비트코인에서는 전자서명 알고리즘으로 ECDSA 라는 타원곡선 상의 DSA 알고리즘을 사용.

13. ECDSA
    ```
    솔직히 이 부분은 도저히 모르겠다,,, DSA 기억이 안난다,,,
    ```
    - ![image](https://user-images.githubusercontent.com/44149738/137494362-7364fd8e-c873-4614-ba70-a316c9a8b81f.png)
    - RSA 방식과 다르게 랜덤한 k를 생성해서 이를 이용하여 전자서명을 도출
    - ![image](https://user-images.githubusercontent.com/44149738/137495166-3198872f-45a5-4feb-b907-56b1b7299237.png)
    - ![image](https://user-images.githubusercontent.com/44149738/137495420-f1003f10-d6a6-4773-b85f-03ddefb4596b.png)
    - 이렇게 전자서명 r과 s가 들어가는 것을 확인할 수 있다.
    - 마지막에 `01` 부분은 hash type을 뜻한다.
        - SIGHASH 라고 불린다.
        - 대부분 ALL 타입을 사용(80% 이상의 TX가 사용)
            - 대부분 애플리케이션도 위에 맞게 구성되어있음
            - 복잡한 타입의 복잡한 SCRIPT를 사용하려면 일반적인 애플리케이션에서 지원하지 않기 때문에 이런 경우에는 별도의 작업을 통해서 코드를 구현해야한다.
        - SIGHASH flag
            - 마지막 1byte 부분
            - tx의 어떤 부분이 message가 되어서 전자서명이 생성됐는지 표현
            - flag
                - 0x01 : all - 모든 input/output 포함.
                - 0x02 : none - 모든 input은 포함하지만 output은 포함하지 않음
                - 0x03 : single - 모든 input은 포함하지만, output은 1개만 포함
        - ANYONECANPAY flag
            - SIGHASH를 사용하면 같이 쓸 수 있음.
            - SIGHASH와 0x08 OR 연산을 진행해서 표현.
            - flag
                - 0x81 : all|ANYONECANPAY - input 1개, output 포함.
                - 0x82 : none|ANYONECANPAY - input 1개, output은 포함하지 않음
                - 0x83 : single|ANYONECANPAY - input 1개, output 1개만 포함
            - 이게 왜 필요한가?
                - 여러 사용자가 tx를 만드는 경우가 있음
                    - 돈 모아서 공동으로 구매하는 경우
                    - 각각의 사용자는 자신의 INPUT에 대한 것만 서명을 확인함으로써 계속 확장해 나갈 수 있음.
        - SIGHASH의 종류
            - ![image](https://user-images.githubusercontent.com/44149738/137497384-51fac9f6-6321-439e-9111-8d71d6a94ab2.png)

        - 사용처
            - ALL|ANYONECANPAY
                - `1 to *`
                - crowdfunding 스타일의 구조에서 사용
                    - 구매를 원하면 자신의 input에만 서명을 하면 됨.
                    - crowdfunding이 무산되어도 애초에 그 tx는 인정되지 않기 때문에 지불을 하지 않은것과 같아서 환불 과정도 간단함.
            - NONE
                - `* to 0`
                - 대상이 없는 수표를 발행하고 싶을 때.
                - 나중에 주고싶은 사람이 생기면 output에 기입하면 됨.
            - NONE|ANYONECANPAY
                - `1 to 0`
                - 기부 형태
                - 개개인의 잔돈? 같은 돈을 조금씩 모음
                - 돈이 모이면 기부대상을 설정해서 보냄.

14. Bitcoin addresses, Balances, and other Absdtractions
    - tx를 분석해주는 사이트 원리
        - input의 UTXO가 있는 tx를 참조해서 송신자 address 구함
        - output의 UTXO가 있는 tx를 참조해서 수신자 address 구함.
    - total received (총 받은 금액)
        - 모든 tx를 검색해서 output의 P2PKH script 내에 bob의 pub key hash가 있는지 확인.
        - 위 조건을 만족하는 output의 합을 구함.
    - final balance(잔고) 구하는 원리
        - UTXO SET을 구성
        - Bob의 UTXO만 따로 구성
        - 다 더함.

15. Multisignature
    - M of N 스키마
        - N명의 사용자 중에서 M명의 사용자가 서명을 하게되면 올바른 서명이라고 판단.
        - locking script 안에 N개의 pubkey를 넣음
        - unlocking script에는 M개 이상만 만족하면 됨
    - locking script (2 of 3)
        - `2 <sig A> <sig B> <sig C> 3 CHECKMULTISIG`
    - unlocking script
        - `<sig B> <sig C>`
    - 공동의 계좌를 사용하는 경우에 활용될 수 있다.
        - 최소 M명 이상의 동의를 구해야만 사용 가능하도록 구성할 수 있음.
    - 개인 계좌의 보안성을 높이기 위해 사용될 수 있다.
        - 여러 기기에 priv key를 보존하기 위해서 사용.
        - 최소 M개 이상의 기기가 존재할 때, 사용할 수 있도록 구성할 수 있음.
    - 백업용도로 사용할 수 있음.
        - KEY를 잃어버려도 다른 KEY를 이용해서 복구할 수 있음.
    - 이 외에도 다양한 하게 활용할 수 있음
        - 2 factor 인증에 사용 : 2 of 2
        - 자식 계좌에 부모 1명 이상의 동의가 필요 : 2 of 3
        - 중고와 같은 거래에서 구매자와 판매자 간 상호 동의가 필요할 때 : 2 of 3
        - ...
    - bug in multisignature
        - 스택에서 하나 더 읽어버리는 버그가 있음
        - 그러나 분산시스템 특성상 이를 수정하기가 어려움
        - 이를 해결하기 위해 unlocking script 작성할 때, 앞에 0을 하나 더 붙이기로 함.

16. P2SH (Pay to script hash)
    - 2012 부터 소개되어서 도입
    - 복잡한 형태의 tx script를 간단하게 바꿔보자!
    - 기존방식으로는 multisig에 pubkey 개수가 많아지면 UTXO가 길어지고, UTXO가 길어지면 그걸 포함하는 TX가 길어진다. -> 수수료가 증가된다.
    - ![image](https://user-images.githubusercontent.com/44149738/137504912-451a9042-823b-404a-bb50-8ebc261bdbb7.png)
    - 위와 같이 이제는 script를 사용자가 가지고 있고, locking script에는 redeem script의 hash값만 가지고 있음.
    - P2SH address
        - p2sh 기반 address를 만드는 방법은 pubkey 사용할때와 비슷하다
        - 방법은 BIP-13으로 지정되어있음
        - script -> hash -> address
    - 장점
        - tx가 작아짐
        - 전송자는 P2SH인지 확인할 필요없이 그냥 address처럼 사용하면 됨.
        - script가 UTXO에 들어가지 않아도 되어서 메모리 공간적 효율이 좋다.
        - 지불 시 script를 입력하면 되므로 script가 기록되는 시기를 늦출 수 있다.
        - 크기가 작아지므로 지불자의 수수료를 줄일 수 있음
            - 반대로 수신자의 수수료는 늘어남.
            - 이 부분은 문제가 없다고 판단
    - 사용 시 주의사항
        - 중간에 추가된 기능이기 때문에 0.9.2 버전 이후부터 사용 가능.
            - 현재는 뭐 거의 사용 가능
        - script는 재귀적일 수 없다. 비트코인에서 이런 부분은 제약을 두고있음.
        - redeem script를 잘못 만들면 복구 불가

17. RETURN
    - 블록체인은 금융 뿐만 아니라 다양한 분야에 사용될 수 있음.
    - 이러한 확장을 가능하게 하는 것이 script이다.
    - script를 다양하게 활용해서 새로운 아이템을 만들어내는 것을 스마트 컨트랙트라고 한다.
    - 금융 거래가 아닌 다른 용도임을 나타내기 위해 RETURN이라는 OP가 생성됨.
    - `RETURN <DATA>` 형태로 사용되며, DATA는 80bytes까지 기록할 수 있음.
    - RETURN이 사용된 output은 UTXO가 아님. 사용할 수 없는 output임. = unlocking script가 없음.
    - 예
        - proof of existence
            - 문서 보장 서비스
            - `RETURN DOCPROOF <hash of document>` 형태로 사용
            - 문서의 생성 시점 및 존재 여부 보장
            - 분쟁 발생 시 증거가 됨
    - 수수료
        - tx fee가 필요하긴 함.

18. Timelock
    - UTXO를 바로 사용하는 것이 아닌, 특정 시간 이후에 사용할 수 있도록 하는 기능.
    - 분류
        - absolute timelock
            - 정확한 시각을 기록
        - relative timelock
            - tx 기준 상대적 시간 기록
    - 사용법
        - tx에 nLocktime 이라는 필드 사용. default = 0
        - 0 ~ 500 million : block height
            - 블록 높이를 기준으로 valid 여부 판단.
        - 그 이상 : timestamp
    - 한계점
        - 3개월 timelock을 걸어두고, 다른 사람한테 지불하는 겨우.
        - 3개월 뒤에는 이미 없어진 tx.
        - 즉, double-spending 문제 발생.
    - check lock time verify (CLTV)
        - absolute timelock 방식
        - 위 문제를 해결하고자 만들어진 방식
        - TX에 LOCK을 거는게 아니라 output에 lock을 거는 방식.
        - `<now + 3 months> CHECKLOCKTIMEVERIFY DROP <script ... >` 형태로 구성
        - 기존 방식과 똑같이 block 기준으로 시간을 정할수도 있다.
    - relative timelock 
        - transaction 레벨에서는 `nSequence` 라는 필드를 사용해서 이용 가능
            - ![image](https://user-images.githubusercontent.com/44149738/138492035-108cd31a-9a2e-4b18-934b-bf65155e4249.png)
            - nSequence (default = 0xffffffff)
            - nSequence가 2^31 보다 작으면 timelock이 걸려있다는 것
            - nLocktime은 tx마다 있었지만 nSequence는 input 필드마다 하나씩 있음.
        - output 레벨에서는 CHECKSEQUENCEVERIFY  opcode 를 사용해서 이용 가능
        - absolute 방식과 거의 비슷함.

19. script 흐름 제어
    - ![image](https://user-images.githubusercontent.com/44149738/138492577-dda42056-1045-4601-b48d-97285e91aa7e.png)
    - IF와 같은 조건을 사용할 수 있음.
    - 그러나 IF를 사용하지 않아도 비슷한 효과를 낼 수는 있음. (guard 문)
        - ![image](https://user-images.githubusercontent.com/44149738/138492849-3c73fa00-b2f5-48aa-9e5f-67abdfb3cf0a.png)
        - script가 복잡한 경우는 if를 사용해야함.
    - if문은 locking script에, if문을 판단할 condition은 unlocking script에 기입.
        - ![image](https://user-images.githubusercontent.com/44149738/138493386-20a06f98-121d-461e-8b89-1d3bf82d7d9e.png)

20. segregated witness
    - utxo 사용 가능하다는 증거자료로 사용됨
    - ![image](https://user-images.githubusercontent.com/44149738/138495236-5bd1191c-37c3-412d-a49a-2d513febb756.png)
    - 위와 같이 input 안에 있던 script 내용을 witness data로 밖으로 빼냄.
    - 이게 왜 좋은가?
        - 기존 비트코인의 문제점
            - tx id는 tx의 hash값임.
            - tx 내용을 바꾸자고 한다면(?) 기존 tx와 의미가 달라짐
            - tx 내 script를 약간 바꿈으로써 같은 내용이지만 다른 의미를 가지도록 할 수 있게됨
            - 이를 이용하여 공격이 가능해짐.
        - 버전정보를 넣을 수 있게 됨.
        - 검증이 끝난 tx는 witness 데이터가 필요 없기 때문에 공간절약이 됨.
            - = 합의성능이 좋아짐
        - 전자서명 알고리즘 개선 등 많은 장점이 있음.
    - segwit은 tx 단위로 돌아가는 것인가?
        - X. output 단위로 돌아감.
        - UTXO마다 segwit이 적용이 될수도, 안될수도 있음
    - segwit 기능이 없는 예전 버전의 sw의 호환성을 위해 soft fork로 업데이트가 진행됨.
    - P2WPKH
        - Pay to Witness Public Key Hash
        - ![image](https://user-images.githubusercontent.com/44149738/138503106-86b56527-4916-4b80-9a8c-f5e69d4c67f1.png)
        - output script가 함축된 형태로 존재
        - check 하는 방식 자체는 기존 P2WPKH 와 비슷한데, witness가 밖으로 빠진다는 점, output script 형태가 좀 달라진다는 점이 다르다.
    - P2WSH
        - Pay to Witness Script Hash
        - ![image](https://user-images.githubusercontent.com/44149738/138503407-5e26d9e7-7149-475e-98fb-19c017c39b9f.png)
        - 32byte의 hash값을 사용하여 P2WPKH와 다르게 표현.


21. Bitcoin network
    - p2p 형태. 중앙서버 존재하지 않음
        - 특정 영역 장애 발생해도 문제 없음
        - 누구나 참여할 수 있고, 오픈이 쉬움
    - node의 종류
        - ![image](https://user-images.githubusercontent.com/44149738/138520889-7a636096-8d6c-47b2-ae6b-99c231048cae.png)
        - W : wallet : key 관리 및 tx를 새로 생성하는 기능
        - M : miner : 새로운 블럭을 생성하는 과정. 최근 tx를 모아 적합한 block을 생성(PoW)
        - B : full blockchain(ledger) :  일부 노드는 장부관리를 해야 함.
        - N : routing node : 기본적으로 모든 노드가 나에게 날아온 tx를 검사하고 전달
    - bitnodes 홈페이지
        - 노드들의 개수, 위치 등의 정보를 알려주는 사이트
    - extended bitcoin network(확장버전)
        - ![image](https://user-images.githubusercontent.com/44149738/138521809-bed548db-6fad-4a46-9780-1cbe91a4afdd.png)
        - mining pool : 채굴을 나눠서 같이하는 형태
        - lightweight wallet client : 보다 가벼운 wallet
    
    - bitcoin relay network
        - miner에게는 bitcoin network의 전파속도가 중요함.
            - 다른사람이 채굴에 성공했는데, 그 소식을 너무 늦게 들으면 다음 채굴도 연달아 늦어짐.
        - miner들 사이에 전파속도를 빠르게 하기 위함.
        - 종류
            - origin bitcoin relay network
                - 2015년에 나옴.
                - AWS를 사용해서 전피
            - Fast Internet Bitcoin Relay Engine (FIBRE)
                - UDP를 사용해서 속도를 높임
            - Falcon
                - 블록 전체를 받지 않아도 일부를 바로 전송하는 형태로 속도를 높임.

22. Network Discovery
    - 새로운 node를 받았다고 했을 때, bitcoin network에 어떻게 연결하는가?
        - 기존의 peer를 찾아서 연결해야함.
        - 랜덤한 노드를 선택해서 연결함
        - 가장 가까운 노드를 선택하지 않는 이유
            - 연결이 집중되거나 고르지 않을 수 있기 때문.
            - 장애 해결 문제, 동기화 문제 등이 있을 수 있음.
        - DNS seed를 이용해서 node들의 ip address를 얻을 수 있음
            - 서버 종류
                - static한 리스트를 제공하는 서버
                    - bitcoin core의 경우.
                - 자체적인 크롤링을 통해서 그 중 랜덤하게 뽑아서 제공 
        - connection을 맺는 과정
            - ![image](https://user-images.githubusercontent.com/44149738/138523357-c20b3f01-01b3-497c-81a1-bd68569b09b7.png)
            - version 안에는 다양한 정보가 있음
            - bestheight는 가장 높은 block을 말함.            
        - 연결 이후 신규 노드 홍보
            - ![image](https://user-images.githubusercontent.com/44149738/138523527-25516f38-6c0c-42dd-8eb9-c2319768c360.png)
            - addr : 나의 ip
            - getaddr : 너가 가지고있는 노드들 ip 줘바
        - 한참동안 트래픽이 없으면 주기적으로 통신해서 살아있는지 확인
            - 90분동안 통신이 안되면 죽은것을 판단하고 새 노드와 연결

23. full node
    - 가장 최신상태의 block들을 다 가지고 있고, 관리하는 노드
    - 탈중앙화의 중심이 됨.
    - 장점 : 다른 노드 도움 없이 독립적으로 tx에 대한 검사를 수행할 수 있어서 중앙화된 기관 필요 없음.
    - 단점 : 운영 자체가 부담. 저장공간도 많이 필요하고, sync 맞추는데 시간이 걸림.
    - 동기화
        - ![image](https://user-images.githubusercontent.com/44149738/138524228-b9f931ea-6509-4b8e-b1e8-d661b474ed6a.png)
        - 기본적으로 genesis block은 sw에 하드코딩 되어있음
        - inv : 받아야하는 블럭 중 500개 블럭에 해당하는 해시값
            - 한 노드가 다 주는게 아님. 그쪽 사정도 생각해야지,,,
        - getdata : block 요청

24. SPV Node
    - full node는 너무 무겁다.
    - 일반적인 사용자는 그정도까지는 필요 없다! 가볍게 해줘! -> spv node
    - full node를 저장하지 않은 상태에서 어떻게 결제(tx 검증)를 진행할 수 있을까?
        - SPV Node는 각각 블럭의 헤더 정보만(바디는 제외하고) 가지고 있음.
            - 헤더만 가져오면 얼마 안됨.
        - tx는 body부분에 들어가게 됨.
    - 완벽하게 안전하게 검증한다고 보기는 어려움
        - 약간의 위험성 존재
        - 그러나 이러한 약간의 위험성만 감수하면 완전 편리해짐
            - 기존에는 tx를 등록하고 반영될 때까지 기다려야 송금이 완료되어서 시간이 오래걸리는데, 얼추 맞다고 판단이 되면 거래는 끝나고, 나중에 tx를 올리면 됨.
    - 조금 더 자세한 거래과정
        - ![image](https://user-images.githubusercontent.com/44149738/138525311-f6e7d18e-7f21-4e38-bb50-2419675159e6.png)
        - 지불자가 tx3를 만든다고 했을 때, tx3에 사용된 input이 어떤 tx의 output인지 알려줌.
        - 수신자는 이를 그대로 믿는것이 아니라 확인과정을 거침.
            - merkle 트리 구조를 이용해서 root까지의 경로 상에 tx가 존재하는지 확인.
            - tx1, 2 depth를 체크해야 함. 6이 넘으면 신뢰도가 매우 높다고 봄.(안전하다)
                - 동기화 차이에 의한 잘못된 기록이 있을 수 있음.
                - 합의 과정을 통해 조정을 하는데, 그 전까지는 불안정.
        - tx3 검증
            - double spending 문제의 위험성이 존재
                - 헤더만 가지고는 사용 여부를 알기 어려움.
            - 두 가지 방식
                - tx가 다른 노드에 의해 기록되어 검증이 되기를 기다림
                    - tx3가 추가 된다면 => double spending 아님
                    - 그러나 6 depth(약 1시간) 정도 기다려야 조금 더 명확하게 신뢰할 수 있음
                    - 소액 결제에는 부적합 ㅠ
                - double spending 위험성을 감수.
                    - 나중에 문제가 발생하면 그때 알아서 처리
                    - 굉장히 빠르고 편리하지만 위험성 존재.
                    - 액수가 크지 않은 경우에 적합. (설마 이 가격인데 사기를 치겠어? 느낌)
    - 블록 헤더에 대한 싱크를 맞추는 방법
        - ![image](https://user-images.githubusercontent.com/44149738/138526324-0c1fb705-ef4d-49d6-bb65-6542392b7eec.png)
        - 한 노드로부터 다 받아오기 보다는 랜덤하게 여러 노드로부터 분산해서 받아온다.
            - 한 노드만 믿고 사기당하면 안되기 때문
            - SPV node 자체가 취약하기 때문에 동기화 받아오는 노드가 사기치면 당한다!
            - 공격자 node가 주변에 있어서 다같이 공격하는 경우도 있음
                - 이 공격을 sybil attack 이라고 함.
    - Bloom Filter
        - full node가 SPV client에게 모든 정보를 줄 필요가 없음
        - SPV client가 받아보는 정보를 보면 사용자가 누군지 특정할 수 있음(익명성을 해침)
        - 안전하게 필요한 정보만 줄 수 있도록 일종의 필터를 사용.
        - 필터가 맞는 트랜젝션이 여러개(본인게 아닌 경우) 있을 수 있음.
            - 남들이 사용자 특정이 보다 어려워짐
            - 효율은 떨어질 수 있음
        - 원리
            - N개 비트와 M개 hash function으로 구성
            - ![image](https://user-images.githubusercontent.com/44149738/142081795-b247946a-0a94-4082-956c-01140b3291a4.png)
            - 초기에는 0으로 초기화되어있음
            - ![image](https://user-images.githubusercontent.com/44149738/142081971-e5aa82b3-ea30-431c-868a-e19a5d884beb.png)
            - pattern의 hash값이 index가 되어 해당 비트를 활성화
            - 이미 활성화되어있는 비트는 그대로 둠

25. blockchain overview
    - data structure
        - block이 이전 block과 연결되어있다.
        - 채굴로 생성된 block이 동시에 생성되면 다음과 같이 가지가 생성될 수 있음
        - ![image](https://user-images.githubusercontent.com/44149738/142083056-29a923df-55d8-4c0e-bbe4-2e61a478cddc.png)
        - 일시적으로 fork가 발생할 수는 있으나, 길게 거시적인 관점에서 보았을 때는 결국 하나에 수렴하는 형태를 띈다.
    - block structure
        - 크게 header, transactions 로 나뉨
            - ![image](https://user-images.githubusercontent.com/44149738/142083447-2caa91e2-beef-4386-bb17-4906a9c70f17.png)
        - 헤더부분은 크진 않음 80bytes 정도
        - 하나의 tx는 보통 4000bytes 정도이고, 하나의 block 안에는 평균 1900개의 tx가 존재
    - block identifiers
        - block을 대표하는 id가 필요. 어떤 데이터를 id로 쓸 것인가?
        - block hash
            - 정확히는 헤더부분에 대한 hash값.
            - sha256 twice를 적용해서 32bytes의 id값을 얻음
        - block height
            - block의 높이로 표현하기도 함.
            - block hash가 너무 길기 때문.
            - 그러나 block height가 유니크하지 않은 경우도 있음.(fork가 발생한 경우)
    - immutability (불변성)
        - 기록되면 변하지 않는 성질
        - ![image](https://user-images.githubusercontent.com/44149738/142084666-cb232b37-501a-4301-80fe-65a30935323d.png)
        - block 내용을 수정하려고 하면 블록 내에 merkle root도 변경되게 되는데, 그렇게 되면 block hash를 맞추기가 무척 어렵다.
        - 그 사이에 block이 쌓이면 그걸 다 변조해야한다.
        - 따라서 block이 몇 개가 쌓여버리면 불변성을 가진다고 판단.

26. Merkle Tree
    - 기본적으로 binary hash tree라는 구조에서 사용
        - tree 구조인데, 각 dir를 hash로 관리
        - 규모가 큰 dataset의 무결성 보장
    - in bitcoin
        - 하나의 블록을 summarize
        - txs들의 대표값으로써 merkle root를 만들어 헤더에 넣음.
        - 헤더는 block hash에 직접적인 연관이 있으므로 hash는 변경되지 않음
        - 효율성 측면의 장점도 있음
            - tx가 해당 블록 안에 있는지 검사를 하려면 txs에 대해 전수조사해야함.
            - merkle root를 사용하게 되면 O(log N) 만큼의 시간이 걸림
                - 1000개의 tx이면 10번정도로 알 수 있음
    - 동작 원리
        - ![image](https://user-images.githubusercontent.com/44149738/142087377-2242df52-2960-44f1-9a96-9af719ca279a.png)
        - A, B, C, D 라는 TX가 있다고 가정.
        - twice hashing을 tree구조 하위부터 타고 올라가면서 진행
    - K tx가 내부에 있는지 확인하는 방법
        - ![image](https://user-images.githubusercontent.com/44149738/142088843-214b0246-06d8-4c8d-b735-309321de448e.png)
        - merkle path : tree 하단부터 타고 올라온 경로
            - HASH 연산을 위해 합친 데이터를 포함.
            - K = { H_L, H_IJ, H_MNOP, H_ABCDEFGH }
        - H_K를 merkel path를 기반으로 한 연산 결과와 같은지 확인.
    - Merkle tree는 SPV에서 많이 사용됨
        - client가 full block을 download 하지 않고 tx를 체크할 수 있음
        - full node는 SPV 노드에게 Merkle block 메세지를 보냄(block header + merkle path)
        - 검증과정에 큰 데이터가 송수신되지 않기 때문에 좋다.
    - Test 용 블록체인
        - testnet
            - 구성은 mainnet과 동일. 그러나 서로 연결되어있지는 않음.
            - 약간의 차이가 있음
                - 여기의 코인은 가짜돈임! 가치가 없음
                - 마이닝 레벨도 매우 낮춤(원활한 테스트를 위해)
            - 공짜로 테스트넷용 비트코인을 받을 수 있는 사이트도 있음
        - regtest
            - testnet도 결국엔 다같이 쓰는거라 테스트가 어려울 수 있음.
            - 아예 로컬상에서 내 머신 안에서 또는 몇대만 가지고 진행.

27. Mining
    - 목적 : clearing(청산)을 처리하는 것. 장부의 내용을 검증.
    - 중앙에서 처리하는 네트워크가 아니기 때문에 여러 노드가 consensus(합의)를 이끌어내는 과정이 필요
    - 개략적 과정
        - miner들은 tx를 계속 받으면서 검증해둠
        - 새로운 block을 만들 시간이 되면 
        - tx들 중 일부를 뽑아서 하나의 블록을 구성
        - tx가 block에 잘 추가가 되어야만 해당 utxo를 사용할 수 있음
    - miner 보상
        - block 생성 시 coin generation
            - 이러한 보상은 4년마다 반감기가 옴.
            - 2140년에는 보상이 0
                - 더이상 새로운 코인 발행 x
                - 채굴자는 수수료를 통해 수익을 얻음
        - tx fee를 가짐
    - 합의 과정
        - 새로운 tx가 생성되면 각 노드들이 tx를 확인
        - tx가 miner들에 의해 하나의 block으로 만들어짐.
        - 새로운 block이 전파되고, 각 노드는 이 새 block에 대해 검증.
        - block이 올바르면 내 blockchain에 등록.
    - tx pool
        - 각 노드가 tx에 대해 검증한 뒤 tx를 저장하는 곳.
        - 검증이 되었지만 chain에 기록되지 않은 tx들이 저장됨.
        - miner가 block을 새로 만들 때, tx pool에서 임의 tx를 모아서 생성하게 됨.
        - block 사이즈 제한때문에 모두 가져올 수는 없고, 이득이 최대화되는 것으로 선정
            - fee가 높은것
    - conbase field
        - genesis block을 봐도 알겠지만 coinbase 필드는 아무 데이터나 들어가도 된다.
        - 그러나 최근에는 특정한 규칙을 만족하고자 함
            - OP_PUSH / Block height / Extra nonce(합의용도) / "/P2SH/"
    - block header
        - ![image](https://user-images.githubusercontent.com/44149738/144741496-21bef1b9-49a3-453b-b627-a9ed7ef34d04.png)
        - 버전, 이전블록해시, tx들의 merkle root, miner가 block을 만든 시간
        - target : 합의를 검증할 때 사용. 채굴의 난이도를 표현하는 데이터
        - Nonce : miner가 제대로된 block을 생성했는지에 대한 검증용도
    - 합의
        - miner가 block을 만들었다고 해서 채굴에 성공한 것은 아님.
        - 다른 노드들에게 인정받기 위해서는 pow 알고리즘을 통해서 만들어진 challenge에 대한 solution을 찾아내면 인정받는다.
            - hash sha256 알고리즘 사용
            - one way function 성질을 이용
        - block header에 Nonce 값이 솔루션을 뜻함.
    - Proof of Work (PoW)
        - 앞 N자리가 0이 되는 hash를 만족하는 nonce를 구해라!
        - nonce를 구하면 채굴 성공! block을 전파.
        - nonce를 기반으로 각 노드는 검증.
    - 합의 알고리즘
        - Proof of Stake
            - 지분을 기반으로.
        - Proof of Ellapsed Time
            - 경과시간을 기다리게 한 다음에 블록을 생성할 수 있도록.
        - PBFT 등 다양하고 복잡한 알고리즘들이 많이 나옴.
    - Proof of Work target
        - 블록 안 특정 필드에 target이 명시되어있음
        - ![image](https://user-images.githubusercontent.com/44149738/144744500-696dc40a-42a6-49aa-b1dd-b01b9495549f.png)
        - mining power에 따라 target을 조절해서 밸런스를 맞춤.
            - 2016 블록마다 계산
            - new target = old target * (2016 block 처리시간 / 20160 minutes)
             
