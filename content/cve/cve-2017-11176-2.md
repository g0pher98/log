---
title: "CVE-2017-11176 part 2"
date: 2021-04-08T12:24:16+09:00
---

[LEXFO](https://blog.lexfo.fr/) 홈페이지에 게시되어있는 CVE-2017-11176 관련 문서를 번역하며 공부했습니다.

## 환경 구축
Step by step 시리즈에서는 CVE-2017-11176 취약점을 이용한 공격을 기반으로 설명한다. 이를 직접 실행하고, 분석해보기 위해 취약한 환경을 구축해야 하는데, part2에서 환경을 구축에 대해서 기술해보고자 한다.

[debian-live-8.6.0-amd64-standard.iso](https://cdimage.debian.org/mirror/cdimage/archive/8.6.0-live/amd64/iso-hybrid/debian-live-8.6.0-amd64-standard.iso)  

취약점 테스트에 사용하게 될 OS는 위와 같다. 클릭하여 다운로드가 가능하다.  
위 OS를 구동하기 위한 시스템은 다음과 같은 조건을 따라야 한다.
- 커널 버전은 반드시 4.11.9보다 낮아야한다. (recommend < 4.x)
- 반드시 "amd64" (x86-64)에서 실행되어야 한다.
- 디버깅을 위해 관리자 접근 권한이 있어야 한다
- 커널은 SLAB 할당자를 사용해야한다
- SMEP 보호기법이 활성화되어있어야 한다
- kASLR과 SMAP 보호기법은 비활성화 해야한다
- 512MB 이상의 메모리를 설정해주어야한다
- CPU 개수는 한개로 설정. 이유는 나중에 알 수 있다.

SLAB/SMEP/SMAP 보호기법에 대해 모른다고 해서 걱정하지 않아도 된다. 뒤쪽 part에서 다룰 예정이다.

주의해야할 점은 위 이미지를 돌리는 가상환경 소프트웨어로 Virtual Box는 적합하지 않다는 점이다. Virtual Box는 SMEP 보호기법 지원이 되지 않는다. 실제로 하다가 수많은 오류에 부딪혀 포기했다.

### Checking SLAB/SMEP/SMAP/KASLR Status
앞서 설명했듯이 실습에 앞서 보호기법 및 각종 기능의 유뮤에 대한 조건을 따라야 한다.
- SLAB 할당자를 사용해야함
- SMEP 활성화
- SMAP 비활성화
- kASLR 비활성화

### SMEP 보호기법 활성화 확인
우선 SMEP가 걸려있는지부터 확인한다.
``` bash
$ grep "smep" /proc/cpuinfo --color
flags   : ... smep ...
```
만약 여기서 SMEP가 걸려있지 않으면 다음과 같이 `/proc/cmdline`에 `nosmep` 옵션이 있는지 확인해보아야 한다.
``` bash
$ grep "smep" /proc/cmdline --color
$
```
smep가 잘 설정되어있다면 위와 같이 아무것도 뜨지 않아야 한다. 만약 `nosmep` 옵션이 걸려있다면 `/etc/default/grub` 파일을 아래와 같이 수정해야한다.
``` bash
# /etc/default/grub
GRUB_CMDLINE_LINUX_DEFAULT="quiet"              // must NOT have "nosmep"
GRUB_CMDLINE_LINUX="initrd=/install/initrd.gz"  // must NOT have "nosmep"
```
수정이 끝나면 `update-grub` 명령을 실행하여 업데이트를 진행한 후 재부팅한다. 만약 이 과정을 수행했음에도 비활성화 되어있다면, 다른 가상화 소프트웨어를 사용하는것을 권장한다.
> ❌ 권고 사항을 무시하고 VirtualBox로 삽질 하다가 크게 혼났다

### SMAP 보호기법 비활성화 확인
반대로 SMAP의 경우 반대로 비활성화 되어야 하기 때문에 결과가 출력되지 않아야 한다.
``` bash
$ grep "smap" /proc/cpuinfo --color
$
```
만약 결과가 출력된다면 `/etc/default/grub` 파일에 `nosmap`옵션을 추가하고, `update-grub` 후 재부팅하는 과정이 필요하다.

### kASLR 보호기법 비활성화 확인
본 시리즈에서 사용하는 공격은 하드코딩된 주소를 사용할 것이다. kASLR은 특정 주소를 알 수 없도록 랜덤한 위치에 할당하는 보호기법이기 때문에 이를 꺼야한다. 방법은 앞서 설명한 것과 같이 `/etc/default/grub` 파일에 아래와 같이 `nokaslr` 옵션을 추가해주면 된다.
``` bash
# /etc/default/grub
GRUB_CMDLINE_LINUX_DEFAULT="quiet nokaslr nosmap"
GRUB_CMDLINE_LINUX="initrd=/install/initrd.gz"
```
이후 진행해야하는 과정도 앞서 설명한것과 같다.

### SLAB 할당자 사용 확인
다음 명령으로 시스템이 SLAB 할당자를 사용하는지 확인할 수 있다.
``` bash
$ grep "CONFIG_SL.B=" /boot/config-$(uname -r)
CONFIG_SLAB=y
```
`CONFIG_SLAB`이 y가 나오면 된다. Ubuntu는 기본적으로 SLUB을  사용하지만, Debian은 SLAB이 기본값이다. 만약 확인 결과 SLAB을 사용하지 않는다면 커널을 다시 컴파일해야한다. 그러나 제공된 ISO는 요구사항을 이미 만족하기 때문에 확인만 하면 된다.

### Installing SystemTap
이번에는 SystemTap이란 것을 설치할 것이다. SystemTap이란, 리눅스 커널 기반 OS들을 동적 분석하기 위해 필요한 디버깅 및 모니터링 툴이다.

앞서 언급한 것과 같이 주어진 ISO는 앞으로 공부할 취약점인 CVE-2017-11176에 취약한 3.16.36 버전의 커널을 사용한다. (`uname -v` 명령으로 확인할 수 있다)

> ❗ 공식적인 SystemTap 설치 메뉴얼을 따라 설치를 진행하게 되면 커널을 업데이트 해버려서 분석해야할 취약점이 사라질 수 있으니 꼭 다음과 같은 방법으로 systemtap을 설치하자.

필요한 파일은 다음과 같다.
- linux-image-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb
- linux-image-3.16.0-4-amd64-dbg_3.16.36-1+deb8u1_amd64.deb
- linux-headers-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb

이 [링크](https://snapshot.debian.org/package/linux/3.16.36-1%2Bdeb8u1/)에서 다운받을 수 있다. 다음 명령으로 debian에 다운로드했다.
``` bash
$ wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-image-3.16.0-4-amd64_3.16.36-1%2Bdeb8u1_amd64.deb
$ wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-image-3.16.0-4-amd64-dbg_3.16.36-1%2Bdeb8u1_amd64.deb
$ wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-headers-3.16.0-4-amd64_3.16.36-1%2Bdeb8u1_amd64.deb
```

위에서 받은 3개의 파일을 모두 다음과 같이 관리자 계정으로 설치했다.
``` 
# dpkg -i linux-*.deb
```
설치가 끝나면 재부팅하여 다음으로 systemtap을 설치한다
```
# apt install systemtap
```
최종적으로 systemtap 설치가 끝났다. 다음 명령을 통해 확인할 수 있다
```
# stap -v -e 'probe vfs.read {printf("read performed\n"); exit()}'
```
`Pass N : ...` 형태의 확인 과정이 진행된다. 아래와 같이 `read performed` 라는 문구가 뜨면 잘 진행된 것이다.
```
stap: Symbol `SSL_ImplementedCiphers' has different size in shared object, consider re-linking
Pass 1: parsed user script and 106 library script(s) using 87832virt/32844res/5328shr/28100data kb, in 100usr/10sys/118real ms.
Pass 2: analyzed script: 1 probe(s), 1 function(s), 3 embed(s), 0 global(s) using 202656virt/149172res/6864shr/142924data kb, in 1180usr/730sys/3789real ms.
Pass 3: translated to C into "/tmp/stapWdpIWC/stap_1390f4a5f16155a0227289d1fa3d97a4_1464_src.c" using 202656virt/149364res/7056shr/142924data kb, in 0usr/20sys/23real ms.
Pass 4: compiled C into "stap_1390f4a5f16155a0227289d1fa3d97a4_1464.ko" in 6310usr/890sys/13392real ms.
Pass 5: starting run.
read performed                    // <---- 이 부분
Pass 5: run completed in 10usr/20sys/309real ms.
```

## 검토
앞서 진행한 과정을 모두 마쳤다면 공격을 수행하면 성공적으로 진행되어야 한다. 다음 과정을 통해 공격을 진행하여 환경이 잘 설정되었는지 확인한다.

본 시스템에서 exploit 코드를 컴파일하고 실행하기 때문에 다음과 같은 패키지를 설치해야한다.
```
# apt install binutils gcc
```
설치가 되었다면 사용자로 권한을 변경한 후 exploit 코드를 다운받는다.
``` bash
$ wget https://raw.githubusercontent.com/lexfo/cve-2017-11176/master/cve-2017-11176.c
```
코드를 컴파일하기 전에 한가지 수정해야하는 부분이 있다. `Use-After-Free` 공격을 진행할 대상 object가 `kmalloc-1024 캐시`가 아닌 `kmalloc-2048 캐시`에 있기 대문이다. 다운받은 코드의 49번째 줄을 다음과 같이 수정해야한다.
``` c++
#define KMALLOC_TARGET 2048 // instead of 1024
```
위 수정사항은 non-targetless exploit(?) 에서 발생하는 문제로, 시리즈의 후반부에 본 수정사항에 대해 이해하게 될 것이다.

이제 공격 코드가 준비되었으니 다음과 같이 컴파일 후 실행하여 공격을 진행할 수 있다.
```
$ gcc -fpic -O0 -std=c99 -Wall -pthread cve-2017-11176.c -o exploit
$ ./exploit
[ ] -={ CVE-2017-11176 Exploit }=-
[+] successfully migrated to CPU#0
[+] userland structures allocated:
[+] g_uland_wq_elt = 0x120001000
[+] g_fake_stack   = 0x20001000
[+] ROP-chain ready
[ ] optmem_max = 20480
[+] can use the 'ancillary data buffer' reallocation gadget!
[+] g_uland_wq_elt.func = 0xffffffff8107b6b8
[+] reallocation data initialized!
[ ] initializing reallocation threads, please wait...
[+] 200 reallocation threads ready!
[+] reallocation ready!
[+] 300 candidates created
[+] parsing '/proc/net/netlink' complete
[+] adjacent candidates found!
[+] netlink candidates ready:
[+] target.pid = -4590
[+] guard.pid  = -4614
[ ] preparing blocking netlink socket
[+] receive buffer reduced
[ ] flooding socket
[+] flood completed
[+] blocking socket ready
[+] netlink fd duplicated (unblock_fd=403, sock_fd2=404)
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 576 fd
[ ][unblock] unblocking now
[+] mq_notify succeed
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 404 fd
[ ][unblock] unblocking now
[ 55.395645] Freeing alive netlink socket ffff88001aca5800
[+] mq_notify succeed
[+] guard socket closed
[ 60.399964] general protection fault: 0000 [#1] SMP
... cut (other crash dump info) ...

<<< HIT CTRL-C >>>
```
실행해보면 관리자권한을 따기는 커녕 무언가 진행이 되다가 더이상 진행이 안되는 것을 볼 수 있다. 아쉽게도 본 exploit 코드는 현재 환경에 맞추어져 있는 코드가 아니기 때문에 앞으로 계속 시리즈를 진행하면서 환경에 맞춘 exploit 코드를 작성해나가야 한다.

비록 공격성공은 하지 못했지만 어느정도 동작하는 것임을 알 수 있다고 원문 필자는 말한다. 아마 보호기법이나 각종 설정이 되어있지 않다면 위 출력결과만큼 나오지 않도록 구성해놓았을 것으로 추정된다.
```
[+] mq_notify succeed
[+] guard socket closed
```
위 출력문 중 마지막 두줄이 출력됨을 확인했다면 고민없이 넘어가도 될 것 같다.

## 커널 소스 가져오기
환경세팅이 끝났다면 한가지 더 해야할 일이 남아있다. 현재 취약점 테스트를 위해 구버전 커널을 사용하고 있다.

```
# wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-source-3.16_3.16.36-1%2Bdeb8u1_all.deb
# dpkg -i linux-source-3.16_3.16.36-1+deb8u1_all.deb
```
커널 소스코드는 `/usr/src/linux-source-3.16.tar.xz`에 위치하게 된다.

exploit 코드는 host system에서 커널 코드를 분석하고 개발해야한다. 즉, ssh를 통해 host system으로 다시 가져와야한다. target system은 exploit 코드를 컴파일 및 실행하거나 systemTap을 실행하는데에만 사용해야한다.

host system과 target system이 명확하게 분리된 상태라면 이제 크롤링이 가능해진다. 리눅스의 소스코드가 워낙 방대하기 때문에 일일이 분석하는건 한계가 있고, 이러한 크롤링 툴을 이용하여 분석의 효율을 높여야 한다. 코드 내의 여러 심볼의 상호 관계를 보다 효율적으로 대조할 수 있도록 도와준다고 한다.

많은 개발자들이 크롤링 도구로 `scope`를 많이 사용한다고 한다. 다음 명령으로 cross-reference를 생성할 수 있다.
```
scope -kqRubv
```
옵션 `-k`는 커널이 독립적(freestanding)으로 실행될 때 라이브러리 헤더를 제외시킨다. cscope database를 생성은 몇 분이 걸릴 수 있다. 데이터베이스 생성이 완료되면 vim과 같이 cscope 관련 플러그인이 있는 편집기를 사용하면 된다. 


여기까지 진행되었다면 모든 준비과정이 끝난 것이다.