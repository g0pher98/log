1. introduction
    - what is internet?
        - nut and bolts 관점(구성품의 관점, 전지적 관점)
            - computing devices
                - 각 장치.
                - a.k.a. `host`
                - a.k.a. `end systems`

            - communication links
                - 각 장치를 연결.
                - transmission rate: bandwidth(대역폭)

            - packet switches
                - 패킷을 전송
                - router and switches
                    - 최근에는 기술에 발전에 의해 차이가 모호해져서 둘이 거의 같은 개념으로 사용.

            - 그냥 network가 아니라 inter(연결) network로, 여러 네트워크를 연결한다는 뜻에서 `network of networks` 라고 함.
            - 네트워크를 연결해주는 사업들이 있음. 이들이 인터넷 서비스를 제공해준다고 볼 수 있는데, 이들을 ISP(Internet Service Provider) 라고 부름
            - protocols
                - 메세지의 송수신을 control 하는 방식을 말함.
                - tcp, ssh, http 등이 있음.
            - internet standards
                - 통신에 표준이 필요함.
                - IETF : 인터넷 프로토콜을 표준화한 단체.
                - RFC : IETF에서 제정한 표준 문서.
        - service 관점(host 관점)
            - 어플리케이션을 서비스하기 위한, 데이터를 주고 받기위한 infra structure. 즉, 인터넷을 사용하기 위한 하부 구조로써 매우 기초적이고 눈에 보이지 않는 구조다.
    - What is protocol?
        - network entity 사이에 주고 받는 message의 format, order, action을 정의하는 것.
            - format: 형식
            - order: 순서
            - action: 행동
    - network edge (네트워크 가장자리)
        - nework 그룹은 크게 세 그룹으로 나누어 볼 수 있음
            - network edge
                - 작은 network에서 router를 제외한 hosts가 이에 해당됨.
                - end systems(hosts), access networks, links 가 존재할 수 있음.
                - server, client가 있고, server는 대부분 data center에 들어있음.
            - access network
                - network edge에 해당하는 여러 host들이 외부 network 연결을 위해 가장 먼저 접근하는 network의 router들이 이에 해당됨.
                - 일반적으로 우리가 생각하는 작은 단위의 네트워크와 같다고 생각하면 될듯.
                - edge router
                    - network edge에서 end system이 통신을 위해 만나는 첫번째 라우터를 말함.
                - keep in mind
                    - bandwidth(속도): (bps: bits per second)
                    - shard network or dedicated network?
            - network core
                - 네트워크에 걸쳐있는 router를 포함한 모든 네트워크 간 연결부를 말함.
    - access network 역사
        - dial-up modem(전화망)
            ![image](https://user-images.githubusercontent.com/44149738/132981901-80b1cc86-d610-4898-8f7d-0fe62de8083b.png)
            - 집에서 central office까지 연결하는데에 이 전화망을 사용함.
                - 집에서 dial-up modem을 사용하여 central office에 도달하고, 이후 인터넷에 접속하는 방식.
            - 56Kbps
            - can't surf and phone at same time. (여러 통신이 동시에 불가.)
            - not always on
        - Digital subscriber line(DSL)
            ![image](https://user-images.githubusercontent.com/44149738/132982032-1f2b4786-c51a-4c83-b2bb-7c7702d087d9.png)
            - 기존 전화망을 사용하되, central office 까지 도달하는 부분이 변경.
            - DSL modem이라는 장치를 통해 속도가 빨라짐.
            - upstream 2.5Mbps
            - downstream 24Mbps
            - 인터넷과 전화서비스를 동시에 지원할 수 있었음.
        - cable network(= cable modem)
            ![image](https://user-images.githubusercontent.com/44149738/132982047-f5bc71b5-da38-4b60-af35-0ec6ecde0ea9.png)
            - 동축선(두꺼움)을 이용.
            - 선으로 통신되는 부분을 채널별로 쪼개서 여러 종류의 데이터를 보낼 수 있도록 구성.
                - 채널을 쪼개는 방식은 다음과 같음
                    - FDM (Frequency Division Multiplexing)
                    - TDM (Time Division Multiplexing)
            - 각 가정이 shared cable(공유되는 케이블)을 이용
                - 집 안에서는 동축선(coax)
                - 각 가정이 공유하는 선은 광섬유(fiber)
                - 이렇게 두 종류의 선을 혼합하는 것을 HFC(Hybrid Fiber Coax)라고 함.
            - asymmetric
                - 데이터 송수신 방식이 비대칭적인 것을 말함.
                - 데이터를 올리는 것보다 다운 받는 경우가 많기 때문.
            - upstream 2Mbps
            - downstream 30Mbps
            - 여러명이 동시에 케이블을 사용할 수 있는 share access network임.
        - FTTH(Fiber To The Home)
            ![image](https://user-images.githubusercontent.com/44149738/132982254-cabfba1c-58f9-4da6-a79b-3bb581110899.png)
            - 제일 중요.
            - 광섬유가 central office에서 집까지 연결되는 방식.
                - 정확히는 OLT 에서 ONU까지
            - 가정에서 가장 많이 사용하는 방식.
            - 속도가 가장 좋다. 1Gbps.

2. access network
    - home network
        - 일반 가정집에서 사용하는 구조
        - NAT역할을 하는 공유기. 보통 유무선 공용임.
    - enterprise access networks(ethernet)
        - 회사나 대학과 같은 곳에서 주로 사용
        - ISP로부터 서비스받고, 이를 라우터로 시작해서 뿌리내리는 형태
        - 공유기와는 급이 다른 성능의 라우터를 사용. 10Gbps까지도 낼 수 있음
    - wireless access networks
        - 무선 통신. 활발히 사용되고 있음
        - 독점이 아닌 공유(shared) 형태의 통신임.
            - 전송속도가 사용자가 많아지면 느려짐.
        - wifi, 4G, 5G와 같은 통신을 통해 access point나 base station(기지국)과 같은 end system에 접근함.
        - 크게 두 가지로 나누어볼 수 있음
            - wireless lan
                - 무선랜, bluetooth
                - 30미터 미만의 빌딩 안과 같은 공간에서 사용
                - WiFi는 802.11b/g/n/a/ac 이라는 표준이 있음 : 11, 54, 450
                    - IEEE 라고 하는 표준화 "단체"
                        - 802 로 시작하는 표준화 "그룹"
                            - 인터넷 네트워크 프로토콜을 표준화 함.
                - 블루투스는 IEEE 802.15.1 WG(working group)에서 표준화 함.
            - wide-area wireless access
                - 3G, 4G:LTE, 5G

3. physical media (물리 매체)
    - physical link
        - 물리적인 통신 경로
        - 두 개로 나누어 볼 수 있음
            - guided media
                - 실제 물리적 통로
                - ex) 구리선 광섬유 동축선
            - unguided media
                - 물리적 통로 없이 전파
                - ex) 라디오

    - guided media 종류
        - twisted pair (TP)
            - guided media 케이블 중 하나
            - 랜선이 이 방식임.
            - 절연구리선을 꼬아놓음
                - 전자기장 간섭을 최소화하기 위함.

        - coaxial cable (동축선)
            - 두 개의 선이 있고, 양방향으로 주고받을 수 있음
            - 여러개의 채널을 하나의 케이블에 담아서 보낼 수 있을 때 사용
            - HFC(Hybrid Fiber and Coax) 방법으로 사용할 수도 있음
            
        - fiber optic cable (광섬유)
            - 유리섬유에 빛으로 비트를 표현
            - 오류가 거의 없음. -> 전자기장에 대한 간섭이 거의 없어서.
                - 즉, 높은 속도로 만들어도 괜찮음! -> 속도가 빠름!
            - 광섬유 특성상 급격히 꺾거나 나누기 어려움. point to point 특성을 가지고 있음.
                - 다른 곳으로 쪼개기 위해서는 splitter와 같은 장비를 이용해서 나눠야함.

    - unguided media 종류
        - radio
            - 전기신호를 흘림에 따라 자기장이 생성됨.
            - 이후 전기장과 자기장의 상호작용을 통해 마치 파동(wave)처럼 퍼져나가게 됨.
            - 선 연결이 필요 없다는 장점
            - 양방향 통신이 가능
            - 벽이나 장애물이 있으면 있으면 회절 및 굴절이 됨.
                - 벽 뒤의 수신자도 통신이 가능
                - 주파수가 올라갈수록 회절이 잘 안됨.
                    - 5G가 직선구간에서만 잘되는 이유도 이것에 해당
            - 종류
                - LAN(WiFi)
                    - AP
                    - 54, 300, 450Mbps
                - wide-area
                    - base station
                    - 4G : ~ 10Mbps
                - terrestrial microwave
                    - base station
                    - DMB 생각하면 됨. 그냥 이런게 있음.
                - satellite
                    - 지구 -> 위성 -> 다른지역 전송
                    - 거리가 멀어서 속도는 떨어짐
                        - end-end 딜레이가 많이 발생
                    - 돈이 많이 들게 됨.
                        - 여러명이 나눠서 써야함.
                            - bandwidth를 줄이고 그만큼 여러개를 만들어야함
                                - 100Mbps 10개 x
                                - 10Mbps 100개 o
                    - 위성의 종류
                        - geosynchronous
                            - 고정위성.
                            - 지구 자전과 같이 돌아서 정지해 있는 것처럼 보임
                            - 매우 높이 있어서 딜레이 큼
                        - low altitude
                            - 유동위성
                            - 비교적 높이가 낮아서 딜레이가 상대적으로 작음
                            - 지구 자전때문에 움직이는것 처럼 보임.
                                - 실제로 사람 입장에서는 움직이는게 맞음

4. network core
    - ![image](https://user-images.githubusercontent.com/44149738/135022931-2d028e40-f777-4723-afc1-657ff82f6b03.png)
    - network core에는 기본적으로 라우터가 그물망처럼 서로 연결되어있음
    - circuit switching 또는 packet-switching 방식을 이용할 수 있음
        - circuit switching
            - 전화선 같은 존재. 하나의 연결마다 독립적인 하나의 회선 제공
        - packet-switching
            - 패킷단위로 쪼갠 다음, end system에 전송
            - link의 전체 용량(capacity)을 모두 사용할 수 있다는 장점이 있음.
                - 자세한건 뒤에서 다룸
    - alternative core: circuit switching
        - 스위치간 통신에서 어떤 회선을 사용할 것인지 선택해서 독점.
        - circuit-like 성능
            - circuit과 거의 같은 성능. 즉, link를 독점하기 때문에 전체를 나혼자 사용하는것과 같은 효과
        - 회선 사용을 예약 했는데 사용하지 않으면 다른 사람이 사용하지 못해서 낭비가 됨.
        - 회선을 쪼개서 사용할 수도 있음
        - 쪼개는 방식은 크게 두 가지가 있음.
            - ![image](https://user-images.githubusercontent.com/44149738/135025490-b669b503-d547-4e56-b4e9-94c61bd16713.png)
            - FDM (Frequency, 주파수)
                - 주파수를 기준으로 분할
            - TDM (Time, 시간)
                - 시간을 기준으로 분할

    - packet switching: queueing delay, loss
        - 먼저 요청된 패킷을 먼저 처리.
        - 예약 시스템의 낭비 문제를 해결할 수 있음
        - 버퍼를 관리하는 과정(queueing)에서 대기로 인한 딜레이가 발생할 수 있음
        - 버퍼가 가득 차면 패킷이 버려짐.(loss)
    
    - circuit switching VS packet switching
        - 동시 사용 : packet switching은 많아도 가능
            - 1Mbps 회선이 있다고 가정하자
            - 100Kbps 데이터를 보낸다고 하면
            - circuit switching
                - 10%를 독점하기 때문에 10명만 사용 가능
            - packet switching
                - 10명 동시사용까지는 원할하게 사용 가능하나, 그 이상부터는 대기시간이 길거나 유실되는 상황 발생 가능
                - 35명이 사용한다고 가정하면, 10명이 동시에 사용할 확률은 `.0004`임. 즉, 35명은 충분히 사용 가능하다고 볼 수 있음.
        - 그렇다면 packet switching이 절대적으로 좋은가?
            - packet switching은 폭발적인 통신이 발생하는 특성을 가진 네트워크에서 효율이 좋다.
            - 여기서 폭발적이란, 지속적인 통신이 아닌, 필요할 때 발생하고 그 외에 사용하지 않을때는 고요한 그런 특성을 말함.
            - 효율적으로 관리한다는 장점이 있지만, 혼잡한 순간이 발생할 수 있다는 단점도 존재한다.
                - 프로토콜을 이용해서 신뢰성을 높이고 혼잡제어 기능이 필요하다.
            - 실시간 서비스는 지속적인 데이터기 때문에 circuit like한 네트워크가 적합해보이지만 사실 아직 이런 기술이 개발되지 않음.

5. 인터넷 구조
    - network of networks. end system이 access ISP 들을 통해서 연결되어있음.
    - 점진적으로 덧붙혀지면서 인터넷이 확대되어오다보니 복잡한 구조를 띔.
        - 복잡한 구조가 된 이유는 경제적, 국가 정책적 이유
    - access net을 서로 연결하면 회선이 너무 많아져서 확장이 어려움.
    - 이를 해결하고자 global ISP가 서로 연결되고, customer가 제공받는 형태로 구성
    - global ISP가 여러개인 경우 서로 연결됨
        - peering 또는 IXP를 통해 연결
    - ![image](https://user-images.githubusercontent.com/44149738/136493591-40946eda-789e-4c8a-8415-a3001007a33e.png)

6. 딜레이
    - ![image](https://user-images.githubusercontent.com/44149738/136501210-ea9f25d3-cce1-4de2-ae89-8a2c75384e75.png)
    - process delay
        - 패킷에 오류검출, 결정 관련 처리 등 패킷을 처리할 때 드는 비용
    - queueing delay
        - 버퍼에서 앞의 패킷이 모두 빠질 때 까지 대기하는 시간
        - 가변적임
    - transmission delay
        - 패킷 전송을 위해 대역폭에 맞게 쪼개서 올리는 시간
        - delay = (Packet Length)/(Link bandwidth) = L/R
    - propagation delay
        - 실제 회선을 타고 출발지부터 목적지까지 이동하는 시간
        - delay = (물리적 회선의 길이) / (전송속도) = d/s
        - transmission delay와는 전혀 관계가 없다.
    - 실제 delay는 얼마나 발생하는가?
        - traceroute 프로그램을 사용하면 됨.

7. 패킷 loss
    - 버퍼가 가득 차면 패킷을 버린다(drop). 이를 loss라고 함.

8. thuroughput (수율)
    - 얼마나 빠르게 보낼 수 있는가를 나타냄
    - instantaneous : 특정 시간에 특정 지점에서
    - average : 긴 시간동안의 평균
    - 가장 대역폭이 작은 link를 `bottleneck link`라고 함.
        - 이 link가 곧 전체의 전송속도를 결정지음.

9. protocol "layers(계층)"
    - protocol stack
        - application
        - transport
        - network
        - link
        - physical
    - OSI 7 Layer
        - ISO에서 제작
        - presentation과 session 계층이 추가됨.
    - encapsulation
        - 계층별 패킷 명칭  
            - application : messasge
            - transport : segment
            - network : datagram
            - link : frame 

10. network security
    - malware
        - virus : 능동적 감염(이메일 첨부파일과 같이 침투함.)
        - worm : 수동적 감염
    - spyware : 은밀하게 활동하는 malware. virus나 worm과 같은 형태로 침투해서 keystrokes, web 기록 등 다양한 정보를 수집해서 특정 사이트(해커의)에 업로드.
    - DDoS(Distributed Denial of Service)
        - 감염이 되면 botnet에 등록되고, 원격지에서 공격자가 조종하게 됨.
    - DoS(Denial of Service)
        - 가짜 트래픽으로 리소스를 점령해버려서 가용성을 떨어트림
        - 여러 기기를 감염시켜서 봇넷에 등록
        - 타겟 서버로 패킷을 특정 시간에 날리도록 명령
    - sniffing
        - broadcast로 보내게 되면 해커도 들을 수 있다.
        - promiscuous network interface로 브로드캐스트된 패킷을 수신할 수 있다.
    - ip spoofing
        - ip를 변조해서 대상을 속이는 공격

11. 인터넷 역사
    - 인터넷은 1960년대에 탄생함 (1961 - 1972)
        - packet-switching 이 더 효율적이라고 판단해서 이것저것 생기던 시기
    - internetworking 시대. (1972 - 1980)
        - net과 net이 만나 internet이 됨.
        - best effort model : 서로 연결된 네트워크가 패킷을 전달하도록 노력은 하지만 목적지까지 간다는 보장은 하지 못함. 
        - 라우터에 패킷의 상태정보가 저장되지 않음.
            - 저장하게 되는 순간부터는 라우터가 하는 일이 너무 많아짐.
        - A, B 네트워크를 연결했다고 해도 서로의 네트워크를 고려할 필요 없음
            - 본인 네트워크만 잘 관리하면 됨.
        - Ethernet이 처음 발생
        - ATM이라는 네트워크의 초기.
        - ARPAnet에 연결된 네트워크가 200개나 됨
    - network가 세련되어짐 (1980 - 1990)
        - tcp/ip가 소개됨
        - smtp, dns, ftp가 제안됨
        - TCP congestion control 알고리즘이 개선됨
        - 국가단위의 national network가 형성됨
        - 10만개 이상의 네트워크 호스트가 연결되게 됨
    - 상업적인 웹 및 앱(1990 - 2000)
        - ARPAnet(기관용) 더 이상 사용하지 않음.
        - NSF 네트워크(연구용) 사용하지 않음
        - 웹의 등장
            - hypertext를 기반으로 버너스리가 만든 문서. HTML, HTTP.
            - 최초의 웹브라우저
                - Mosaic -> 나중에 넷스케이프로 바뀜 -> explorer -> chrome 등
        - killer app : 서비스의 핵심이 되는 앱
            - 메신저, p2p 파일공유
        - network security가 주목받기 시작함.
        - 5천만개의 host, 1억명 이상의 사용자가 인터넷을 사용함.
        - Gbps가 운영되기 시작
    - 2005 - 현재
        - 50억개 device가 인터넷에 연결.(핸드폰, tv 등)
        - broadband access (광대역 접근)가 가능한 서비스 등장
            - 언제 어디서든지 접속하고싶다!
        - high speed wireless access
            - 4G, 5G, WiFi 등
        - SNS 서비스 등장
        - 거대한 IT 회사들이 자신이 소유한 네트워크(CDN)을 만들기 시작함.

12. network app
    - 애플리케이션 계층에서의 서비스는 쉽게 구성할 수 있다.
    - 라우터와 같은 network-core device를 고려할 필요 없다.
    - 즉, end system만 신경써서 개발할 수 있기 때문에 빠른 개발이 가능하다. sw 전파도 end system에만 설치하면 되어 빠르게 가능.

13. application architectures
    - client-server 아키텍처
        - server는 항상 켜져있음. 고정된 ip가 있음.
        - client가 server에 접속을 함.
        - client는 보통 dhcp를 사용 == ip가 동적으로 할당됨.
        - client 끼리 통신을 위해 server를 꼭 거쳐야 함. (상하구조)
    - p2p 아키텍처
        - 상대방과 직접 통신 가능 (수평구조)
        - peer to peer
        - 서로 요청 및 제공이 가능.
        - peer가 무수히 많아도 서비스 가능
            - self scalability 하다 => 새로운 peer가 들어오면 서비스를 요청하기도 하지만 제공도 하기 때문에 결국엔 확장되어 리소스 문제가 없다(?)

    - process communicating
        - process : 실행되고있는 프로그램
        - inter-process communication : 같은 호스트 내 서로다른 프로세스가 통신 가능
        - 그렇다면 다른 호스트의 프로세스가 커뮤니케이션하려면?
            - 하나는 client process(요청자), 나머지 하나는 server process(수신자)가 됨.
            - os에게 다른 호스트에게 요청하라고 명령해야함.
                - socket 사용
        - sockets
            - process는 socket을 통해서 os 밖 다른 host와 통신할 수 있다.
            - 호스트와 프로세스를 구별할 수 있는 identifier가 필요함.
                - 일반적으로 ip와 port 정보 필요.
                - http(80), mail(25) 와 같이 일반적으로 사용되는 포트가 있음.

    - app-layer protocol defines
        - type(ex. req|resp)이 정의되어야 함.
        - message syntax가 정의되어야 함. (프로토콜 별 정해진 필드 같은 느낌.)
        - message semantics 정의.
            - 메세지 안의 필드가 "의미"하는게 무엇인지.
        - 메세지를 언제, 어떻게 주고받을지 rule을 정해야함.
        - 이렇게 만들어진 프로토콜의 종류
            - open protocols
                - RFC로 구조가 공표된 프로토콜
                - 상호 운영이 가능하도록 하기 위함
            - proprietary protocols
                - 개인적인 프로토콜
                - ex) skype, 각종 게임 등
    
    - application layer의 프로토콜이 메세지를 전송할 때, 전송계층에 기대할 수 있는 기능
        - data loss
            - 파일전송과 같은 서비스는 무조건 loss가 있으면 안됨.
            - 그러나 오디오와 같은 서비스는 어느정도의 loss를 허용하기도 함.
            - application마다 transport 계층에 요구하는 사항이 다를 수 있다.
        - timing
            - 게임이나 전화처럼 매우 낮은 딜레이를 원하는 서비스가 있을 수 있음
            - 반대로 파일전송과 같이 크게 민감하지 않은 경우도 있음. 
        - throughput
            - minimum throughput이 중요한 서비스가 있을 수 있음.
                - 비디오 서비스와 같은 경우는 중간에 끊기면 안되기 때문에 중요
            - 반대로 작아도 상관없는 경우도 있음
                - 이런 서비스를 elastic apps 라고 함.
                - throughput이 크면 좋지만 작아도 상관없음.
        - security
            - 데이터의 변조 없이 정확하게 전달.
            - encryption과 같은 것.
    
        - 종류별 서비스들의 요구사항
            - ![image](https://user-images.githubusercontent.com/44149738/137630129-c68bba44-1139-4349-a567-d4ed7114b17d.png)

14. 실제 transport 프로토콜
    - tcp
        - 신뢰할 수 있는 프로토콜
            - 송신자가 보낸 데이터는 수신자가 무조건 똑같이 받는다
        - flow control
            - sender가 너무 빠르지 않게 receiver가 받을 수 있는 속도로 조절해서 보냄.
        - congestion control
            - network 혼잡상태에 따라 전송 속도 조절.
        - 제공하지 않는 것
            - timing
            - minium throughput
            - guarantee, security
        - security는 왜 제공하지 않는가?
            - 초창기에는 보안이 중요하지 않았기 때문에 구성되지 않음
            - SSL(Secure Socket Layer)
                - 보안성이 제공되는 소켓 레이어를 말함
                - end point를 인증하는 기능으로 사용할 수 있음
                - application 단에서 구현됨.
                - 암호화 한 후 tcp에게 전달.
    - udp
        - 신뢰할 수 없는 프로토콜
            - 손실이 발생할 수 있다
            - 굳이 손실을 방지하지 않음
        - simple함.
        - 스트리밍 서비스에 주로 사용

15. web and http
    - web page란 여러 objects(이미지, 제목, 표, 등)들로 구성된 페이지
    - 기본이 되는 html 파일이 있고, referenced object를 포함하는 형태로 되어있다.
    - 웹페이지를 지칭하는 identifier가 있음 == URL(hostname + pathname)
    - HTTP
        - web page를 전달할 때 사용하는 프로토콜
        - server/client model
            - client : http 프로토콜을 통해 web object를 요청 및 수신하여 브라우저에 띄움.
            - server : http 프로토콜을 통해 요청에 대한 결과를 전송한다.
        - 기본적으로 stateless 형태로 구성되어있다.
            - 상태정보. 즉, 과거에 대한 저장이 없다.
            - 프로토콜이 상태정보를 저장하게 되면 프로토콜이 매우 복잡해지기 때문
    - non-persistent HTTP   
        - 매 요청마다 TCP connection을 맺음.
        - response time
            - RTT (Round Trip Time)
                - 왕복 시간을 말함
            - connection을 위한 RTT + HTTP 처리를 위한 RTT + 처리시간
        - issue
            - object마다 2RTT 시간이 필요함.
            - TCP를 열었다 닫았다를 반복하면서 os overhead 발생
            - 2RTT라는 시간을 줄이기 위해 종종 여러개의 tcp를 병렬로 한번에 열어서 데이터를 한번에 받아오는 방법도 있는데, 그래도 각각의 TCP CONNECTION이 Object마다 열려야 한다는 부분은 해결이 안됨.
    - persistent HTTP
        - tcp 연결을 열면 끝나고 나서 close 한다.
        - 추가적인 http 메세지가 열려있는 tcp connection을 이용
        - 약 1RTT(약간 큼)의 시간에 받아올 수 있음.
        - 열려있는 TCP로 여러개 OBJECT를 받을 수 있기 때문에 object에 따른 os overhead도 비교적 적다.
    - HTTP syntax
        - 사람이 읽을 수 있는 ascii로 되어있음
        - `/r/n` : carriage return + line feed : 개행에 사용
        - `request line`과 `header lines`로 나뉨
        - request line 형태: `GET /index.html HTTP/1.1/r/n` 
        - header lines 형태: `Header field Name : Values`
    - method
        - get : 데이터를 url로 전송
        - post : 데이터를 form으로 body 부분에 담아 전송
        - head : 서버는 object를 줄 필요는 없어요~
        - 버전별
            - HTTP/1.0
                - GET, POST, HEAD
            - HTTP/1.1
                - GET, POST, HEAD
                - PUT
                    - 파일을 업로드
                - DELETE
                    - 파일을 삭제
    - HTTP response
        - status line, header lines, blank line, entity body 로 이루어져 있음
        - status code
            - 200 : OK
            - 301 : Moved Permanently. 현재 요청한 리소스가 다른 위치로 이동했음을 뜻함. (Location: 이동한 위치)
            - 400 : Bad request. web 서버가 요청을 이해하지 못함. http 버전에 맞게 요청이 구성되지 않을 경우 많이 뜸.
            - 404 : Not found. 자원이 없음.
            - 505 : HTTP Version Not Supported. HTTP 버전이 안맞는 경우.
    
16. cookie
    - cookie를 사용하는 방법
        - HTTP response에 cookie 헤더가 포함되어있어야 함
        - HTTP request에 cookie를 담아 서버에 알려줄 수 있다.
        - cookie file은 웹 브라우저에 의해 관리됨.
        - 쿠키에 대한 백엔드 데이터베이스가 있어야 한다(??????? 개발자 마음 아닌가 ?)
    - cookie 사용처
        - authorization : 인증
        - shopping carts : 장바구니
        - recommendations : 추천기능
        - user session state : 세션
    - state를 유지하는 방법
        - 프로토콜의 endpoints에 저장.
    - privacy
        - 웹사이트가 나에 대해 너무 많은 걸 알게됨.
        - 요즘에는 쿠키도 개인정보로 다루어짐 

17. web caches (= proxy server?)
    - client가 object 원본까지 가지 않아도 되도록 함을 목적으로 함.
    - 리소스(트래픽), 응답속도 측면에서 좋음
    - client(origin server 입장에서)이면서 동시에 server(real client 입장에서)임.
    - ISP에 의해서 대학이나 회사 등에 설치됨.
    - conditional get
        - 캐시 방식의 고질적인 문제가 있음.
            - origin server 변경으로 인한 차이가 발생할 수 있음.
        - 이를 해결하기 위해 나온게 conditional get
        - 일정 시간이 지나면 origin server에 최신버전인지 질의
        - If-modified-since 헤더를 이용해서 확인
            - 수정사항 없으면 304
            - 수정사항 있으면 200과 함께 데이터 응답

18. Electronic mail
    - 주요 요소
        - user agent(e-mail app)
        - mail server
        - smtp protocol
    - user agent
        - mail reader app
        - e.g. outlook, thunderbird, iphone mail, web browser, ...
    - mail server
        - mailbox와 message queue로 이루어져 있음
        - mailbox
            - 도착한 메세지를 저장하는 공간
        - message queue
            - 사용자가 메일을 전송하려고 할 때, 저장하는 큐
        - smtp protocol 사용
    - SMTP
        - TCP 사용. 25번포트.
        - 메일서버끼리 직접적으로 주고받음
        - 3 단계에 거쳐 메일을 전송
            - handshaking 
            - transfer of messages
            - closure
        - command/response (like http, ftp)
            - commands : ascii text
            - response: status code and phrase(ascii)
        - message는 반드시 7bit ascii로만 전송하도록 되어있음.
        - HTTP와의 비슷한점/다른점
            - http는 pull이지만 smtp는 push다.
            - 둘 다 ascii 코드로 이루어져 있고, `<status_code> <status_phrase>` 구조로 이루어진 req/resp 관계가 있다.
            - 차이점
                - http : 하나의 response에는 하나의 object만 들어갈 수 있음
                - smtp : 하나의 object가 여러개의 msg에 들어갈 수 있고, 여러개의 object가 하나의 msg에 들어갈 수도 있음.
        - 구조는 RFC 822에 표준화 되어있음.

19. mail access protocols
    - SMTP : 수신자의 ms까지 전송하고, 저장하는 프로토콜
    - mail access protocol: 수신자의 ms에서 메일을 읽을 때 사용하는 프로토콜
        - POP(Post Ofiice Protocol - RFC 1939)
            - 사용자 인증, 메일 다운로드
        - IMAP(Internet Mail Access Protocol - RFC 1730)
            - 더 다양한 기능, email을 정리 및 재정렬하는 기능
        - HTTP
            - Gmail, Hotmail, etc.
            - 가장 많이 사용하는 형태
    - POP3
        - 110번 포트
        - 버전3 가 가장 유명
        - ASCII를 이용해서 req, res
        - ![image](https://user-images.githubusercontent.com/44149738/139498073-49625643-84e2-417e-9ba2-361c713e71f5.png)
        - 인증 과정(authorization phase)
            - client commands
                - user : 유저명
                - pass : 비번
            - server res
                - `+OK`
                - `-ERR`
        - 메일 다운로드 과정 (transaction phase)
            - list : 메일 번호, 메일 크기 리스팅
            - retr : 번호에 해당하는 메일 받기
            - dele : 번호에 해당하는 메일 삭제
            - quit : 종료
        - pop3 tmi
            - 기본적으로 download and delete 형태임. 받고 삭제.
            - delete를 안하도록 설정할 수 있음.
                - 그러나 메일박스가 계속 차게 됨
            - stateless한 세션임. 즉, 이전 세션을 기억하지 않음.
    - IMAP
        - 서버에 모두 저장하는 형태
        - 이전 세션을 기억함.
            - 변경사항이 그대로 유지됨.

20. DNS
    - Domain Name System
    - IP주소와 Hostname을 번역하는 서비스
    - 계층적으로 분산된 데이터베이스 형태로 구현되어있음
    - 응용계층 layer로 구현되어있음.
        - 그 이유는 인터넷 초기에는 DNS 필요성을 못느껴서 존재하지 않았기 때문.
        - 이미 인터넷 환경이 발전한 후에 고안되었기 때문에 응용계층으로 구현
    - 서비스
        - hostname -> ip
        - host aliasing(별칭)
        - mail server aliasing(메일서버 정보)
        - load distribution
            - 웹 서버를 중복해서 설치해놓고 많은 ip를 하나의 hostname에 매핑
            - 이렇게 해서 부하가 분산되도록 할 수 있음.(로드밸런싱?)
    - DNS가 단일(중앙집중형)이 아닌 이유
        - SPoF(Single Point of Failure) 문제 발생
        - 트래픽 양도 어마무시함.
        - 거리가 멀면 멀수록 속도가 느려짐
        - 업데이트 요청이 많아지면 거기에 시간을 너무 쏟게됨.
    - 계층
        - 크게 3개로 나누어짐
        1. Root DNS
            - 전 세계에 13개 정도만 있어도 운영이 됨.
        2. Top Level DNS (TLD)
            - `.com`
            - `.org`
            - ...
        3. Authoritative DNS
            - 기관이 운영하는 고유한 서버
            - `kknock.org`
            - `naver.com`
            - ...
        - 질의 과정 (www.amazon.com 질의 가정)
            0. local dns server에 질의 후 캐싱된 내용이 없다면 다음으로 넘어감
            1. root dns에 `.com` dns server 주소를 질의
            2. `.com` dns server에 `amazon.com` dns server 주소를 질의
            3. `amazon.com` dns server에 `www.amazon.com` 주소 질의
    - Local DNS name server
        - 위 DNS 3계층에 포함되지는 않음.
        - Local DNS에 가장 먼저 질의. 모르면 기본 DNS 동작 수행
        - dns 정보를 캐싱하거나, 데이터베이스를 구성해둔 proxy 역할을 하는 것으로 볼 수 있음.
    - 질의 방식
        1. iterated query(반복적 쿼리)
            - ![image](https://user-images.githubusercontent.com/44149738/139502576-2a3a6fc9-721f-4f90-b340-7c9c17837b56.png)
            - "나는 모르지만, 여기 dns 서버로 가봐!" 개념
        2. recursive query(재귀적 쿼리)
            - 질의 과정을 다음 dns로 넘겨버리는 방식
            - root에 가까운 dns 서버에 부하가 심해짐.
    - 캐싱, 레코드 업데이트
        - dns는 질의 결과를 추후 cache로 활용.
        - 그러나 캐시를 활용하면 업데이트 문제가 발생.
            - timeout을 두어서 갱신해야함(TTL).
            - 그럼에도 업데이트 갭이 발생할 수 있음.
                - TTL 값을 얼만큼으로 둘 것인가가 중요. 아직도 논의되고 있음.
        - 반면 TLD 서버의 경우 잘 변경되지 않기 때문에 고정한다.
    - DNS 레코드
        - RR(Resource Records)
            - ![image](https://user-images.githubusercontent.com/44149738/139503248-6173cedb-c841-472d-ac67-9f1b3588fe67.png)
            - type
                - A
                    - name = hostname
                    - value = IP주소
                - NS
                    - name = domain
                    - value = 해당 도메인을 담당하는 authoritative ns의 hostname
                - CNAME (Canonical name)
                    - name = 별명 name
                    - value = 별명에 해당하는 실제 name
                - MX
                    - name = domain
                    - value = 메일서버의 hostname
    - dns protocol messages
        - query와 reply 메세지로 구성되어있음
            - 그런데 포맷이 같음!
        - ![image](https://user-images.githubusercontent.com/44149738/139504128-95d0ee3d-49ab-4f85-897e-2d02de9c0075.png)
        - msg header
            - identification
                - dns query의 특정 번호.
            - flags
                - query(0) or reply(1)
                - recursion 방식 요청
                - recursion available!
                - reply is authoritative
                    - authoritative로부터 도착한 최종 답변
            - number of questions : 질의 내용
            - number of answer RRs : 답변 내용
            - number of authority RRs : 하위 ns 정보
            - number of additional RRs : 추가 도움되는 정보를 담는 공간


21. 터널링
    - 터널링과 VPN
        - 터널링
            - 인터넷을 사적이고 안전한 네트워크의 일부로 사용하게 하는 기술
        - 캡슐화
            - 터널 장비를 지날 때, 2계층 이상의 정보를 벗겨내지 않고 캡슐화
            - ![image](https://user-images.githubusercontent.com/44149738/141281078-ff14d70c-5b83-408f-a7e0-915351771d8a.png)
            - 대표적으로 VPN
        - VPN (Virtual Private Network)
            - 터널링의 대표적인 보안 장비
        - Internal Network (or IntraNet)
            - 기업 내부 데이터 통신용 네트워크
            - 인터넷과 구분된 별도의 임대회선(leased line) 사용
            - 가격이 고가임
                - 임대 회선과 비슷한 수준의 기밀성을 제공하려면 vpn 사용 및 암호화 필요
                - vpn 암호화 프로토콜에는 PPTP, L2TF, IPSec, SSL 등이 있음
        - 실습 - vpn
            - 환경: ubuntu 14
            - apt install openvpn easy-rsa
            - sudo vi /etc/openvpn/server.conf 
                - 다음과 같이 설정
                - ![image](https://user-images.githubusercontent.com/44149738/141300789-8aaac699-5a84-4b67-9e6f-31b23cb432ab.png)
            - sudo vi /etc/sysctl.conf
                - 다음과 같이 설정
                    - ![image](https://user-images.githubusercontent.com/44149738/141300865-997f51fb-f396-4898-a38e-9edc048c85ba.png)
            - cp -r /usr/share/easy-rsa/ /etc/openvpn
            - mkdir /etc/openvpn/easy-rsa/keys # 키 저장공간 생성
            - sudo vi /etc/openvpn/easy-rsa/vars
                - 다음과 같이 본인 설정에 맞게 자유롭게 변경
                - ![image](https://user-images.githubusercontent.com/44149738/141301785-68e94c59-84e8-4e28-af10-3ee9aa5eb0aa.png)
            - openssl dhparam -out /etc/openvpn/dh2048.pem 2048 # 인증서에 사용할 디피헬만키 생성
            - cd /etc/openvpn/easy-rsa
            - source ./vars
            - ./clean-all
            - ./build-ca # ca 인증서 생성
            - ./build-key-server server # 서버의 인증서와 키 생성
            - ls /etc/openvpn/easy-rsa/keys
                - 여기에 ca.pem, crt, key 그리고 server.crt, csr, key 이렇게 다 있는지 확인
                - 이거를 openvpn에 넣어주면 됨
            - cp /etc/openvpn/easy-rsa/keys/ca.crt /etc/openvpn
            - cp /etc/openvpn/easy-rsa/keys/server.crt /etc/openvpn
            - cp /etc/openvpn/easy-rsa/keys/server.key /etc/openvpn
            - 이제 시작
            - service openvpn start
            - service openvpn status
            - 클라이언트 인증서와 키 생성
            - cd /etc/openvpn/easy-rsa
            - ./build-key client01
            - 클라이언트(windows)에서도 openvpn 설치.
                - 이것도 예전버전으로. 2.3.11
                - 실행 시 관리자권한으로.
            - 프로그램이 설치된 폴더에서 config/client.ovpn 파일 열어서 수정
                - 아래 부분도 수정
                - ![image](https://user-images.githubusercontent.com/44149738/141307801-291acc22-64ff-4f16-9e1f-4f7d9fc89c4f.png)
                - remote 부분의 ip를 서버의 ip로  잘 설정해주어야 함. 포트는 1194
            - ubuntu 에서 ca.crt랑, client01.cr, client01.key 3개 파일을 윈도우로 가져옴.
                - config 폴더에 넣음
            - openvpn을 실행해서 트레이 우클릭 후 connect!
            - ping(win -> ubuntu) 과정을 ubuntu에서 wireshark로 캡쳐해보기
                - openvpn으로 암호화 됨
        - 실습2 - ssh 터널링
            - win7, ubuntu 14 환경.
            - apt install openssh-server # ssh 설치
            - vi /etc/ssh/sshd-config 파일의 내용 아래와 같이 수정.
                - 없으면 생성.
                - ![image](https://user-images.githubusercontent.com/44149738/141615516-c81a21ee-093c-46d9-a811-b1e184f166d0.png)
            - /etc/init.d/ssh restart # ssh 재시작
            - windows에서 putty로 접속 
            - 인터넷도 옵션에서 프록시 5000 포트로 설정하면 터널링된 상태로 통신
    - 은닉채널
        - 은닉 메세지를 전송하기 위해 기본 통신 채널에 기생하는 채널
        - ackcmd 툴
            - ack 패킷만 이용해서 세션을 성립시키지 않음.
            - ack 패킷 안에 숨겨진 데이터를 주고받음.
            - 세션이 맺어지지 않아서 방화벽에 탐지도 안됨.
            - 그러나 너무 많으면 탐지할 수도 있으니 live 여부정도나 간단한 커맨드 정도로 사용
            - 공격 후 백도어로 데이터 송수신에 사용할 수도 있을 듯
        - 어떻게 방어할 수 있을까? 어떻게 방어를 우회할 수 있을까?
            - 요즘 머신러닝을 이용해서 탐지.
        - dns2tcp 툴
            - ubuntu 14, ubuntu server 16 환경
            - 서버에서 dns2tcp 세팅
                - apt install dns2tcp
                - vi ./dns2tcpd_config
                    - ![image](https://user-images.githubusercontent.com/44149738/141644633-4230ea7b-94a9-45ec-8eba-3d40f63c45f6.png)
                - dns2tcpd -d 3 -f ./dns2tcpd_config
                    - 만약 충돌나면 udp 53 포트 사용중인 것.
                    - 프로세스에서 kill 해야함.
            - 클라이언트에서 dns2tcp 세팅
                - apt install dns2tcp
                - vi ./dns2tcpc_config
                    - ![image](https://user-images.githubusercontent.com/44149738/141644694-4927db0a-7e8c-46ef-b329-610df6077a46.png)
                - dns2tcpc -f ./dns2tcpc_config
            - udp를 이용해서 ssh 접속이 가능해짐. dns를 이용해 은닉하는 방법
    