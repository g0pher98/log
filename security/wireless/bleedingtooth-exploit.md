# BleedingTooth exploit
본 문서는 구글 security-research 레포에 올라가있는 [bleedingtooth 디렉토리](https://github.com/google/security-research/tree/master/pocs/linux/bleedingtooth) 내부 자료를 번역하며 재구성한 글입니다. bleedingtooth의 세부 공격인 badChoice, badKarma는 다른 파일로 구성했으며, 본 글은 해당 지식을 전제로 기술되어있습니다.

## Exploitation
RCE는 BadChoice 취약점을 BadKarma 또는 BadVibes와 결합하여 진행할 수 있다. 본 글에서는 BadChoie와 BadKarma를 결합하여 사용한다. 그 이유는 다음과 같다.

- BadVibes와 달리 bluetooth 버전에 제약이 없음
- 피해자를 스캔할 필요 없음
- 타겟팅된 공격이 가능함

### Bypassing BadKarma
BadKarma를 익스하기 위해서는 BadKarma 취약점을 우회해야한다. 말에 모순이 있어보이지만 A2MP 채널이 ERTM/STREAMING 으로 설정되면 BadKarma 취약점으로 인해 정상적으로 A2MP 서브루틴까지 도달할 수가 없기 때문이다.

`l2cap_data_channel()` 함수에서 switch 문에서 `chan->mode`를 검사하는 로직을 살펴보자.

```c++
static void l2cap_data_channel(struct l2cap_conn *conn, u16 cid,
			       struct sk_buff *skb)
{
	struct l2cap_chan *chan;

	chan = l2cap_get_chan_by_scid(conn, cid);
	
	// ...

	switch (chan->mode) {
	case L2CAP_MODE_LE_FLOWCTL:
	case L2CAP_MODE_EXT_FLOWCTL:
		if (l2cap_ecred_data_rcv(chan, skb) < 0)
			goto drop;

		goto done;

	case L2CAP_MODE_BASIC:
		/* If socket recv buffers overflows we drop data here
		 * which is *bad* because L2CAP has to be reliable.
		 * But we don't have any other choice. L2CAP doesn't
		 * provide flow control mechanism. */

		if (chan->imtu < skb->len) {
			BT_ERR("Dropping L2CAP data: receive buffer overflow");
			goto drop;
		}

		if (!chan->ops->recv(chan, skb)) // recv 함수 사용
			goto done;
		break;

	case L2CAP_MODE_ERTM:        // 여기는 취약점이 트리거되어서 사용 불가
	case L2CAP_MODE_STREAMING:
		l2cap_data_rcv(chan, skb);
		goto done;

	default:
		BT_DBG("chan %p: bad mode 0x%2.2x", chan, chan->mode);
		break;
	}
	// ...
}
```

ERTM/STREAMING 외에 A2MP 서브루틴을 사용하는 `L2CAP_MODE_BASIC`이 눈에 띈다. 이 모드를 통해 접근하게 되면 A2MP의 `recv` 루틴이 호출된다. 그러나 BadKarma를 분석하면서 A2MP 채널은 기본적으로 ERTM/STREAMING 으로 설정되는 것을 확인했다. 그렇다면 `L2CAP_MODE_BASIC`으로 mode를 어떻게 전환할 수 있을까? 아래 함수에 주목하자.

```c++
static inline int l2cap_config_rsp(struct l2cap_conn *conn,
				   struct l2cap_cmd_hdr *cmd, u16 cmd_len,
				   u8 *data)
{
	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;

	// ...

	scid   = __le16_to_cpu(rsp->scid);
	flags  = __le16_to_cpu(rsp->flags);
	result = __le16_to_cpu(rsp->result);

	BT_DBG("scid 0x%4.4x flags 0x%2.2x result 0x%2.2x len %d", scid, flags,
	       result, len);

	chan = l2cap_get_chan_by_scid(conn, scid);
	if (!chan)
		return 0;

	switch (result) {

	// ...

	case L2CAP_CONF_UNACCEPT:
		if (chan->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {
			// ...
			result = L2CAP_CONF_SUCCESS;
			len = l2cap_parse_conf_rsp(chan, rsp->data, len,
						   req, sizeof(req), &result);
			// ...
		}
		fallthrough;
	
    // ...
	}
	// ...
}
```

result가 `L2CAP_CONF_UNACCEPT`로 설정되면 위 함수는 `l2cap_parse_conf_rsp()` 함수를 호출한다. 해당 함수 내용은 아래와 같다.

```c++
static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,
				void *data, size_t size, u16 *result)
{
	// ...
	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC }; // 우리가 원하는 모드

	// ...

	while (len >= L2CAP_CONF_OPT_SIZE) {
		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
		if (len < 0)
			break;

		switch (type) {

		// ...

		case L2CAP_CONF_RFC:
			if (olen != sizeof(rfc))
				break;
			memcpy(&rfc, (void *)val, olen); // rfc 재설정
			if (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&
			    rfc.mode != chan->mode)
				return -ECONNREFUSED;
			chan->fcs = 0;
			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
					   (unsigned long) &rfc, endptr - ptr);
			break;

		// ...
	}

	if (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode)
		return -ECONNREFUSED;

	chan->mode = rfc.mode; // chan->mode를 재설정 하는 부분 

	// ...
}
```

`chan->mode`를 재설정 하는 부분을 확인할 수 있다. 여기에 삽입되는 `rfc`는 type이 `L2CAP_CONF_RFC`로 설정되면 `L2CAP_MODE_BASIC`로 mode 필드를 변경할 수 있다. 이 코드까지 트리거하기 위한 전제조건인 `L2CAP_CONF_UNACECT` 역시 상호 확인없이 일방적으로 설정할 수 있기 때문에 어렵지 않다.

이제 위 방법을 통해 A2MP 기능을 사용할 수 있게 되면 BadChoice를 이용해서 익스에 필요한 여러 정보를 릭 할 수 있다. 준비가 끝나면 연결을 재설정해서 ERTM 모드로 변경해서 BadKarma 공격을 진행하면 된다.


### Exploring sk_filter()
이미 분석했듯이 BadKarma 공격은 `amp_mgr` 구조체가 `sk_filter()`의 `sock` 구조체로 인식되면서 발생하는 type confusion 취약점이다. 그렇다면 sock 구조체는 어떻게 사용될까? 문제의 `sk_filter()` 함수부터 살펴보자

```c++
static inline int sk_filter(struct sock *sk, struct sk_buff *skb)
{
	return sk_filter_trim_cap(sk, skb, 1);
}
```
sk 라는 인자로 받아서 `sk_filter_trim_cap()`에 바로 넘긴다. 해당 함수 내용은 아래와 같다.

```c++
int sk_filter_trim_cap(struct sock *sk, struct sk_buff *skb, unsigned int cap)
{
	int err;
	struct sk_filter *filter;

	/*
	 * If the skb was allocated from pfmemalloc reserves, only
	 * allow SOCK_MEMALLOC sockets to use it as this socket is
	 * helping free memory
	 */
	if (skb_pfmemalloc(skb) && !sock_flag(sk, SOCK_MEMALLOC)) {
		NET_INC_STATS(sock_net(sk), LINUX_MIB_PFMEMALLOCDROP);
		return -ENOMEM;
	}
	err = BPF_CGROUP_RUN_PROG_INET_INGRESS(sk, skb);
	if (err)
		return err;

	err = security_sock_rcv_skb(sk, skb);
	if (err)
		return err;

	rcu_read_lock();
	filter = rcu_dereference(sk->sk_filter);
	if (filter) {
		struct sock *save_sk = skb->sk;
		unsigned int pkt_len;

		skb->sk = sk;
		pkt_len = bpf_prog_run_save_cb(filter->prog, skb);
		skb->sk = save_sk;
		err = pkt_len ? pskb_trim(skb, max(cap, pkt_len)) : -EPERM;
	}
	rcu_read_unlock();

	return err;
}
```
위 함수에서도 sk 라는 변수로 받고, `sock_flag()` 함수에서 가장 먼저 사용한다. 그러나 `skb_pfmemalloc()` 조건이 만족해야하기 때문에 일단 넘긴다. 그 다음은 `BPF_CGROUP_RUN_PROG_INET_INGRESS()` 함수에서 사용하는데, 이 부분을 살펴보자.

```c++
#define BPF_CGROUP_RUN_PROG_INET_INGRESS(sk, skb)			\
({															\
	int __ret = 0;											\
	if (cgroup_bpf_enabled)									\
		__ret = __cgroup_bpf_run_filter_skb(sk, skb,		\
						    BPF_CGROUP_INET_INGRESS);		\
															\
	__ret;													\
})
```
내부에서 `__cgroup_bpf_run_filter_skb()` 함수에 바로 넘긴다. 해당 함수는 아래와 같다.

```c++
int __cgroup_bpf_run_filter_skb(struct sock *sk,
				struct sk_buff *skb,
				enum bpf_attach_type type)
{
	...
	if (!sk || !sk_fullsock(sk))
		return 0;

	if (sk->sk_family != AF_INET && sk->sk_family != AF_INET6)
		return 0;
	...
}
```
`sk_fullsock()` 함수에서도 특별한 행위는 하지 않는다. 바로 아래에 있는 조건문을 살펴보면 `sk->sk_family`가 `AF_INET(2)` 또는 `AF_INET6(10)`의 값을 가져야 종료되지 않는다.

``` c++
struct sock {
	struct sock_common {
		...
		short unsigned int skc_family;   // offset : 0x10, length : 0x2
		...
	} __sk_common; /*     0  0x88 */
	...
	struct sk_filter * sk_filter;  // offset : 0x110, length : 0x8
	...
	/* size: 760, cachelines: 12, members: 88 */
	/* sum members: 747, holes: 4, sum holes: 8 */
	/* sum bitfield members: 40 bits (5 bytes) */
	/* paddings: 1, sum paddings: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 56 bytes */
} __attribute__((__aligned__(8)));
```
sock 구조체의 `sk_family` 필드는 sock_common 구조체 내부에 선언되어있으며, 0x10의 offset 값을 가진다. 그렇다면 type confusion이 발생했을 때, amp_mgr의 경우는 어떨까?

```c++
struct amp_mgr {
	// ...
	struct l2cap_conn * l2cap_conn;   // offset : 0x10, length : 0x8
	// ...
	/* size: 112, cachelines: 2, members: 11 */
	/* sum members: 110, holes: 1, sum holes: 2 */
	/* last cacheline: 48 bytes */
};
```
amp_mgr 구조체에서 offset 0x10에는 l2cap_conn 구조체가 존재한다. l2cap_conn 구조체는 최소 32bytes 크기인 힙 개체 포인터이기 때문에 `__cgroup_bpf_run_filter_skb()` 함수에서 요구하는 조건을 맞춰줄 수 없다. 결국 항상 0을 반환하게 된다. `BPF_CGROUP_RUN_PROG_INET_INGRESS()` 함수 바로 다음에서 sk를 사용하는 `security_sock_rcv_skb()` 함수도 위와 같은 조건이 필요하며 만족하지 않으면 0을 반환한다.

sk_filter 구조체에 대한 제어가 어떻게 활용되는지는 추후 알아보겠지만, 

```
TODO : 잘 이해가 안됨.

`sk->sk_filter`는 유일하게 충돌을 일으킬 잠재적인 멤버이다.
```

`sk_filter` 필드는 sock 구조체의 0x110 offset에 존재하지만, 이를 조작하기에는 amp_mgr 구조체의 전체 크기가 112bytes (0x70) 밖에 되지 않는다. 일반적인 상황에서는 이를 조작하는것이 불가능에 가깝겠지만, amp_mgr이 kmalloc-64 slab의 크기보다 크고 kmalloc-128 slab의 크기보다는 작기 때문에 kmalloc-128 slab에 할당될 것임을 생각해보면 불가능한 이야기는 아니다.

slab 특성상 메타데이터가 없고, 128bytes씩 연속적으로 생성될 것임을 고려하면, 0x110(272) offset에 접근하기 위해서 slab 블록 2개(256) 이후 블록의 0x10 offset에 접근하면 된다. 즉, amp_mgr 구조체가 할당된 블록 이후 두 번째 블록에서 0x10 오프셋에 조작 가능한 힙 공간을 생성하면 `sk_filter` 조작이 가능하다.


### Finding a Heap Primitive
kmalloc-128 슬랩을 할당하기 위해서는 65-128바이트 크기의 메모리를 할당할 수 있는 명령이 필요하다. 이를 위해 우리는 임의의 크기의 메모리를 할당하고, 원하는 데이터를 복사해둔 뒤, 원할 때까지 힙에서 free 되지 않는 조건을 만족하는 방법을 찾아야 한다. `kmemdup()` 함수가 이에 해당하는데, 실제로 A2MP 프로토콜에서 이를 제공하는 부분이 있다. `A2MP_GETAMPASOC_RSP` 명령을 수행할 때 실행되는 `a2mp_getampassoc_rsp()` 함수를 살펴보자 

```c++
static int a2mp_getampassoc_rsp(struct amp_mgr *mgr, struct sk_buff *skb,
				struct a2mp_cmd *hdr)
{
	...
	u16 len = le16_to_cpu(hdr->len);
	...
	assoc_len = len - sizeof(*rsp);
	...
	ctrl = amp_ctrl_lookup(mgr, rsp->id); // 정상적인 amp_ctrl 구조체를 반환해야 함.
	if (ctrl) {
		u8 *assoc;

		assoc = kmemdup(rsp->amp_assoc, assoc_len, GFP_KERNEL); // kmemdup 사용
		if (!assoc) {
			amp_ctrl_put(ctrl);
			return -ENOMEM;
		}

		ctrl->assoc = assoc; // ctrl->assoc 에 새 메모리 주소 저장
		ctrl->assoc_len = assoc_len;
		ctrl->assoc_rem_len = assoc_len;
		ctrl->assoc_len_so_far = 0;

		amp_ctrl_put(ctrl);
	}
	...
}
```
ctrl이 정상적인 amp_ctrl 구조체를 반환하면 `kmemdup()` 함수를 사용할 수 있다. 이를 위해서는 ctrl 리스트에 먼저 제어 구조를 추가해 두어야 하는데, `A2MP_GETINFO_RSP` 명령을 통해 이를 수행할 수 있다.

```c++
static int a2mp_getinfo_rsp(struct amp_mgr *mgr, struct sk_buff *skb,
			    struct a2mp_cmd *hdr)
{
	struct a2mp_info_rsp *rsp = (struct a2mp_info_rsp *) skb->data;
	...
	ctrl = amp_ctrl_add(mgr, rsp->id);
	...
}
```
`a2mp_getinfo_rsp()` 함수에서 `amp_ctrl_add()` 함수를 통해 ctrl을 추가하는 것을 확인할 수 있다.

```
TODO : 잘 이해가 안됨.

이 kmemdup은 임의의 크기와 내용으로 조작할 수 있기 때문에 완벽한 힙 가젯이다. 유일한 단점은 원할 때 free를 진행할 수 있는 코드가 없다는 것이다. 할당된 힙 영역을 free하기 위해서 HCI 연결을 끊어버리면 된다. 그러나 이런 방법으로 힙 영역을 free 하기 위해서는 메모리 관리 부분에 주의를 기울여한다.

`ctrl->assoc` 에 새 메모리 주소를 저장할 때, 이전 메모리 블록을 free 하지 않는다. 오히려 그 블록은 계속해서 재정의할 때 간단히 사라진다.

그래서 이 동작을 사용하기 위해서는 두 번째 `ctrl->assoc`를 더 큰 크기로 할당해서 나머지 절반은 해제되고, 재정의한 부분은 할당된 상태로 유지되도록 하면 된다.
```

### Controlling the Out-Of-Bounds Read
힙 스프레이를 320개나 뿌리고, amp_mgr 구조체를 할당했을 때, 뿌려진 object 근처에 할당되면 sk_filter를 제어할 수 있음을 설명.

### Leaking the Memory Layout
sk_filter를 제어할 수는 있는데 어디로 제어해야하는가? 이를 위해 badchoice를 이용할 수 있음.
- text 세그먼트의 포인터가 노출되어 text base를 구할 수 있음.
- L2CAP_CONF_RSP를 전송하고 A2MP 채널을 L2CAP_MODE_ERTM으로 재구성하면 오프셋 0x110에서 L2CAP_chan 구조체의 주소가 노출될 수 있음. (이 구조체는 크기가 792 바이트라서 kmalloc-1024 슬랩에 할당됨)

다음과 같이 공격.
1. l2cap_chan 구조체 주소 릭
2. a2mp 연결을 끊어버려서 l2cap_chan 할당 해제.
3. 다시 연결해서 kmalloc-1024 슬랩 힙 스프레이

### Plugging It All Together
- 커널에서 쉘코드 실행은 어려우므로 유저영역으로 넘어가기 위해서 커널 피봇팅 진행함.
- rop에 사용할 가젯 찾기
- rop chain 구성
- 익스~

