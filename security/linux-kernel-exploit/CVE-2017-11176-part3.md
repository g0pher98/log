# CVE-2017-11176 part3
[LEXFO](https://blog.lexfo.fr/) í™ˆí˜ì´ì§€ì— ê²Œì‹œë˜ì–´ìˆëŠ” CVE-2017-11176 ê´€ë ¨ ë¬¸ì„œë¥¼ ë²ˆì—­í•˜ë©° ê³µë¶€í–ˆìŠµë‹ˆë‹¤.

<br>
part1ì—ì„œëŠ” CVE ì·¨ì•½ì ì„ ë¶„ì„í•˜ê¸° ìœ„í•œ í•µì‹¬ ê°œë…ë“¤ì„ ì†Œê°œí–ˆë‹¤. 

ìš°ë¦¬ëŠ” ë²„ê·¸ê°€ ìœ íš¨í•˜ë„ë¡ SystemTapì˜ ë„ì›€ì„ ë°›ì•„ ì»¤ë„ì˜ì—­ìœ¼ë¡œì˜ íŠ¸ë¦¬ê±°ë¥¼ ê°•ì œí–ˆë‹¤. ê·¸ë¦¬ê³  ê¶Œí•œìƒìŠ¹ì€ ì•„ë‹ˆì§€ë§Œ exploit ì½”ë“œë¥¼ ì‹¤í–‰í•´ì„œ ì·¨ì•½ì„±ì„ ì¦ëª…í•´ ë³´ì˜€ë‹¤.

ì´ë²ˆ partì—ì„œëŠ” SystemTap ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì—†ì• ê³  ì˜¤ì§ ìœ ì €ì˜ì—­ ì½”ë“œë§Œì„ ì´ìš©í•´ì„œ ìœ„ íŠ¸ë¦¬ê±° ì¡°ê±´ì„ ë§Œì¡±ì‹œí‚¤ë„ë¡ ì™„ì „í•œ POC ì½”ë“œë¥¼ ì»´íŒŒì¼í•´ë³¼ ê²ƒì´ë‹¤.

# í•µì‹¬ê°œë… #2
ë‘ ë²ˆì§¸ "í•µì‹¬ê°œë…"ì—ì„œëŠ” scheduler sybsystemì´ ì†Œê°œëœë‹¤. ì—¬ê¸°ì„œ ì´ˆì ì„ ë‘ì–´ì•¼ í•˜ëŠ” ë¶€ë¶„ì€ `task ìƒíƒœ`ì— ëŒ€í•œ ë¶€ë¶„ê³¼ `taskì˜ ìƒíƒœê°€ ì–´ë–»ê²Œ ì „í™˜ë˜ëŠ”ì§€`ì— ëŒ€í•œ ë¶€ë¶„ì´ë‹¤.

ìŠ¤ë ˆë“œ unblockì— ì‚¬ìš©ë  ëŒ€ê¸° í(wait queue)ë¥¼ ê°•ì¡°í•˜ë©°, exploitì¤‘ì— arbitrary call primitiveë¥¼ íšë“í•  ìˆ˜ ìˆë‹¤.

## Task State
taskì˜ ìƒíƒœëŠ” `task_struct` êµ¬ì¡°ì²´ì˜ `state` í•„ë“œì— ì €ì¥ëœë‹¤. taskëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ì˜ ìƒíƒœë¡œ ì¡´ì¬í•œë‹¤.

- Running : í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ì¤‘ì´ê±°ë‚˜ CPU ì‚¬ìš©ì„ ìœ„í•´ ëŒ€ê¸°ì¤‘ì„.
- Waiting : í”„ë¡œì„¸ìŠ¤ê°€ event/resourceë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ waiting/sleeping ì¤‘ì„.

`Running ìƒíƒœì˜ task`(TASK_RUNNING)ëŠ” run queueì— ì†í•´ìˆëŠ” taskë‹¤. CPUë¥¼ ì¦‰ì‹œ ì‚¬ìš©í•  ìˆ˜ ìˆê±°ë‚˜ ê°€ê¹Œìš´ ë¯¸ë˜ì— ì‹¤í–‰ë  ìˆ˜ ìˆë‹¤.

`Waiting ìƒíƒœì˜ task`ëŠ” ì–´ë– í•œ CPUì—ì„œë„ ì‹¤í–‰ë˜ê³  ìˆì§€ ì•Šë‹¤. wait queueë‚˜ signalì— ì˜í•´ wake-up ë  ìˆ˜ ìˆë‹¤. waiting taskì˜ ê°€ì¥ ê¸°ë³¸ì ì¸ ìƒíƒœëŠ” TASK_INTERRUPTIBLE(i.e. "sleeping" ìƒíƒœê°€ ì¤‘ë‹¨ë  ìˆ˜ ìˆëŠ” ìƒíƒœ)

task stateëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ëœë‹¤.
``` c++
// [include/linux/sched.h]

#define TASK_RUNNING        0
#define TASK_INTERRUPTIBLE  1
// ... ë‹¤ë¥¸ ìƒíƒœ ë³€ìˆ˜ë“¤
```
state fieldëŠ” ì§ì ‘ ì¡°ì‘í•˜ê±°ë‚˜ í˜„ì¬ taskì˜ stateë¥¼ ìˆ˜ì •í•˜ëŠ” `__set_current_state()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¡°ì‘í•  ìˆ˜ ìˆë‹¤.
``` c++
// [include/linux/sched.h]

#define __set_current_state(state_value)            \
    do { current->state = (state_value); } while (0)
```

## Queue ì‹¤í–‰
`rq(run queue)` êµ¬ì¡°ì²´ëŠ” ìŠ¤ì¼€ì¥´ëŸ¬ì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ ë°ì´í„° êµ¬ì¡°ì¤‘ í•˜ë‚˜ë‹¤. ëª¨ë“  taskëŠ” run queueì— ì˜¬ë¼ê°€ ìˆìœ¼ë©°, CPUì— ì˜í•´ ì‹¤í–‰ë  ê²ƒì´ë‹¤. ëª¨ë“  CPUëŠ” ê°ìì˜ run queueë¥¼ ê°€ì§€ê³  ìˆë‹¤. ì´ëŠ” ì§€ì •ëœ CPUë¡œ ì‹¤í–‰í•˜ê¸° ìœ„í•´ ìŠ¤ì¼€ì¥´ëŸ¬ì— ì˜í•´ ì„ íƒ ê°€ëŠ¥í•œ taskì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ê°€ì§€ê³  ìˆë‹¤. ë˜í•œ ìŠ¤ì¼€ì¥´ëŸ¬ê°€ ê° taskì— ì˜í•´ ê³µí‰í•œ ì„ íƒì„ í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” í†µê³„ë¥¼ ê°€ì§€ê³  ìˆìœ¼ë©°, ì´ë¥¼ í†µí•´ CPU ë¶€í•˜ë¥¼ ì¤„ì¼ ìˆ˜ ìˆë‹¤(i.e. cpu migration).
``` c++
// [kernel/sched.c]

struct rq {
  unsigned long nr_running;   // <----- í†µê³„ ê´€ë ¨ ë°ì´í„°
  u64 nr_switches;            // <----- í†µê³„ ê´€ë ¨ ë°ì´í„°
  struct task_struct *curr;   // <----- í˜„ì¬ CPUë¥¼ ì‚¬ìš©ì¤‘ì¸ task
  // ...
};
```
> ğŸ” CFS(Complete Fair Scheduler)ë¥¼ ì‚¬ìš©í•˜ë©´ ì‹¤ì œ task listê°€ ì €ì¥ë˜ëŠ” ë°©ì‹ì´ ë‹¤ì†Œ ë³µì¡í•˜ì§€ë§Œ ì—¬ê¸°ì„œ ë¬¸ì œë˜ì§„ ì•ŠëŠ”ë‹¤.

ë‹¹ì—°í•˜ê²Œë„ run queueì—ì„œ ë¹ ì ¸ë‚˜ì˜¨ taskëŠ” ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤(i.e. ì‹¤í–‰í•  CPUê°€ ì—†ìŒ). `deactivate_task()`ê°€ ë°”ë¡œ ì´ëŸ¬í•œ run queueì—ì„œ taskë¥¼ ë¹¼ë‚´ëŠ” ì‘ì—…ì„ í•œë‹¤. ë°˜ëŒ€ë¡œ `activate_task()`ëŠ” run queueì— taskë¥¼ ë„£ëŠ” ì‘ì—…ì„ í•œë‹¤.

## taskì™€ schedule() ì°¨ë‹¨
taskê°€ running ìƒíƒœì—ì„œ waiting ìƒíƒœë¡œ ì „í™˜ë˜ë ¤ë©´ ë‹¤ìŒ ë‘ ê°€ì§€ ì´ìƒì„ ë™ì‘ì„ ìˆ˜í–‰í•´ì•¼í•œë‹¤.

1. ìŠ¤ìŠ¤ë¡œì˜ running stateë¥¼ `TASK_INTERRUPTIBLE` ìƒíƒœë¡œ ë³€ê²½
2. `deactivat_task()`ë¥¼ í˜¸ì¶œí•˜ì—¬ run queue ë°–ìœ¼ë¡œ ë¹ ì ¸ë‚˜ì˜´.

ì‹¤ì œë¡œ ì•„ë¬´ë„ diactivate_task()ë¥¼ ì§ì ‘ í˜¸ì¶œí•˜ì§€ ì•ŠëŠ”ë‹¤. ëŒ€ì‹ , schedule()ì´ í˜¸ì¶œëœë‹¤.

schedule() í•¨ìˆ˜ëŠ” ìŠ¤ì¼€ì¥´ëŸ¬ì˜ ë©”ì¸ì´ ë˜ëŠ” í•¨ìˆ˜ë‹¤. ì´ í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œ, ë‹¤ìŒ running taskëŠ” CPUë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì„ íƒë  ê²ƒì´ë‹¤. ê³ ë¡œ, run queueì˜ `curr` í•„ë“œë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼í•œë‹¤.


``` c++
asmlinkage void __sched schedule(void)
{
struct task_struct *prev, *next;
unsigned long *switch_count;
struct rq *rq;
int cpu;

    // ... cut ...

prev = rq->curr;    // <---- "prev" is the task running on the current CPU

if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {   // <----- ignore the "preempt" stuff
    if (unlikely(signal_pending_state(prev->state, prev)))
    prev->state = TASK_RUNNING;
    else
    deactivate_task(rq, prev, DEQUEUE_SLEEP);     // <----- task is moved out of run queue
    switch_count = &prev->nvcsw;
}

// ... cut (choose the next task) ...
}
```


``` c++
void make_it_block(void)
{
  __set_current_state(TASK_INTERRUPTIBLE);
  schedule();
}
```


``` c++
// [include/linux/wait.h]

typedef struct __wait_queue_head wait_queue_head_t;

struct __wait_queue_head {
    spinlock_t lock;
    struct list_head task_list;
};
```


``` c++
// [include/linux.wait.h]

typedef struct __wait_queue wait_queue_t;
typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key);

struct __wait_queue {
    unsigned int flags;
    void *private;                
    wait_queue_func_t func;     // <----- we will get back to this
    struct list_head task_list;
};
```

``` c++
// [include/linux/wait.h]

#define __WAITQUEUE_INITIALIZER(name, tsk) {                \
    .private    = tsk,                      \
    .func       = default_wake_function,            \
    .task_list  = { NULL, NULL } }

#define DECLARE_WAITQUEUE(name, tsk)                    \
    wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk) // <----- it creates a variable!
```

``` c++
DECLARE_WAITQUEUE(my_wait_queue_elt, current); // <----- use the "current" macro
```



``` c++
// [kernel/wait.c]

void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)
{
    unsigned long flags;

    wait->flags &= ~WQ_FLAG_EXCLUSIVE;
    spin_lock_irqsave(&q->lock, flags);
    __add_wait_queue(q, wait);              // <----- here
    spin_unlock_irqrestore(&q->lock, flags);
}

static inline void __add_wait_queue(wait_queue_head_t *head, wait_queue_t *new)
{
    list_add(&new->task_list, &head->task_list);
}
```


``` c++
// [kernel/sched.c]

/**
 * __wake_up - wake up threads blocked on a waitqueue.
 * @q: the waitqueue
 * @mode: which threads
 * @nr_exclusive: how many wake-one or wake-many threads to wake up
 * @key: is directly passed to the wakeup function
 *
 * It may be assumed that this function implies a write memory barrier before
 * changing the task state if and only if any tasks are woken up.
 */

void __wake_up(wait_queue_head_t *q, unsigned int mode,
            int nr_exclusive, void *key)
{
    unsigned long flags;

    spin_lock_irqsave(&q->lock, flags);
    __wake_up_common(q, mode, nr_exclusive, 0, key);    // <----- here
    spin_unlock_irqrestore(&q->lock, flags);
}
```

``` c++
// [kernel/sched.c]

static void __wake_up_common(wait_queue_head_t *q, unsigned int mode,
        int nr_exclusive, int wake_flags, void *key)
{
    wait_queue_t *curr, *next;

[0]   list_for_each_entry_safe(curr, next, &q->task_list, task_list) {
    unsigned flags = curr->flags;

[1]     if (curr->func(curr, mode, wake_flags, key) &&
        (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)
        break;
    }
}
```